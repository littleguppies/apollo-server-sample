module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateAssign {
  count: Int!
}

type AggregateAttachment {
  count: Int!
}

type AggregateCategory {
  count: Int!
}

type AggregateCertification {
  count: Int!
}

type AggregateCompany {
  count: Int!
}

type AggregateContact {
  count: Int!
}

type AggregateConversation {
  count: Int!
}

type AggregateEducation {
  count: Int!
}

type AggregateEmployer {
  count: Int!
}

type AggregateemployerInvitedFreelancer {
  count: Int!
}

type AggregateEmployerShortList {
  count: Int!
}

type AggregateExperience {
  count: Int!
}

type AggregateFreelancer {
  count: Int!
}

type AggregateFreelancerShortList {
  count: Int!
}

type AggregateHire {
  count: Int!
}

type AggregateInterview {
  count: Int!
}

type AggregateJob {
  count: Int!
}

type AggregateLanguageSkill {
  count: Int!
}

type AggregateListOfProject {
  count: Int!
}

type AggregateNeedSkill {
  count: Int!
}

type AggregateNotification {
  count: Int!
}

type AggregateNotificationBody {
  count: Int!
}

type AggregateOffer {
  count: Int!
}

type AggregatePaymentForTask {
  count: Int!
}

type AggregatepaymentTypeOffer {
  count: Int!
}

type AggregatePortfolio {
  count: Int!
}

type AggregateProject {
  count: Int!
}

type AggregateProposal {
  count: Int!
}

type AggregatePublication {
  count: Int!
}

type AggregateSkill {
  count: Int!
}

type AggregateTask {
  count: Int!
}

type AggregateTest {
  count: Int!
}

type AggregateText {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Assign {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  task: Task
  freelancer: Freelancer!
  totalTime: Int!
}

type AssignConnection {
  pageInfo: PageInfo!
  edges: [AssignEdge]!
  aggregate: AggregateAssign!
}

input AssignCreateInput {
  id: ID
  task: TaskCreateOneWithoutAssignInput
  freelancer: FreelancerCreateOneInput!
  totalTime: Int
}

input AssignCreateManyWithoutTaskInput {
  create: [AssignCreateWithoutTaskInput!]
  connect: [AssignWhereUniqueInput!]
}

input AssignCreateWithoutTaskInput {
  id: ID
  freelancer: FreelancerCreateOneInput!
  totalTime: Int
}

type AssignEdge {
  node: Assign!
  cursor: String!
}

enum AssignOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  totalTime_ASC
  totalTime_DESC
}

type AssignPreviousValues {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  totalTime: Int!
}

input AssignScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  totalTime: Int
  totalTime_not: Int
  totalTime_in: [Int!]
  totalTime_not_in: [Int!]
  totalTime_lt: Int
  totalTime_lte: Int
  totalTime_gt: Int
  totalTime_gte: Int
  AND: [AssignScalarWhereInput!]
  OR: [AssignScalarWhereInput!]
  NOT: [AssignScalarWhereInput!]
}

type AssignSubscriptionPayload {
  mutation: MutationType!
  node: Assign
  updatedFields: [String!]
  previousValues: AssignPreviousValues
}

input AssignSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AssignWhereInput
  AND: [AssignSubscriptionWhereInput!]
  OR: [AssignSubscriptionWhereInput!]
  NOT: [AssignSubscriptionWhereInput!]
}

input AssignUpdateInput {
  task: TaskUpdateOneWithoutAssignInput
  freelancer: FreelancerUpdateOneRequiredInput
  totalTime: Int
}

input AssignUpdateManyDataInput {
  totalTime: Int
}

input AssignUpdateManyMutationInput {
  totalTime: Int
}

input AssignUpdateManyWithoutTaskInput {
  create: [AssignCreateWithoutTaskInput!]
  delete: [AssignWhereUniqueInput!]
  connect: [AssignWhereUniqueInput!]
  set: [AssignWhereUniqueInput!]
  disconnect: [AssignWhereUniqueInput!]
  update: [AssignUpdateWithWhereUniqueWithoutTaskInput!]
  upsert: [AssignUpsertWithWhereUniqueWithoutTaskInput!]
  deleteMany: [AssignScalarWhereInput!]
  updateMany: [AssignUpdateManyWithWhereNestedInput!]
}

input AssignUpdateManyWithWhereNestedInput {
  where: AssignScalarWhereInput!
  data: AssignUpdateManyDataInput!
}

input AssignUpdateWithoutTaskDataInput {
  freelancer: FreelancerUpdateOneRequiredInput
  totalTime: Int
}

input AssignUpdateWithWhereUniqueWithoutTaskInput {
  where: AssignWhereUniqueInput!
  data: AssignUpdateWithoutTaskDataInput!
}

input AssignUpsertWithWhereUniqueWithoutTaskInput {
  where: AssignWhereUniqueInput!
  update: AssignUpdateWithoutTaskDataInput!
  create: AssignCreateWithoutTaskInput!
}

input AssignWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  task: TaskWhereInput
  freelancer: FreelancerWhereInput
  totalTime: Int
  totalTime_not: Int
  totalTime_in: [Int!]
  totalTime_not_in: [Int!]
  totalTime_lt: Int
  totalTime_lte: Int
  totalTime_gt: Int
  totalTime_gte: Int
  AND: [AssignWhereInput!]
  OR: [AssignWhereInput!]
  NOT: [AssignWhereInput!]
}

input AssignWhereUniqueInput {
  id: ID
}

type Attachment {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  type: String
  author_name: String
  title: String
  title_link: String
  image_url: String
  asset_url: String!
  thumb_url: String
  extention: String
  author: User
}

type AttachmentConnection {
  pageInfo: PageInfo!
  edges: [AttachmentEdge]!
  aggregate: AggregateAttachment!
}

input AttachmentCreateInput {
  id: ID
  type: String
  author_name: String
  title: String
  title_link: String
  image_url: String
  asset_url: String!
  thumb_url: String
  extention: String
  author: UserCreateOneInput
}

input AttachmentCreateManyInput {
  create: [AttachmentCreateInput!]
  connect: [AttachmentWhereUniqueInput!]
}

type AttachmentEdge {
  node: Attachment!
  cursor: String!
}

enum AttachmentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  type_ASC
  type_DESC
  author_name_ASC
  author_name_DESC
  title_ASC
  title_DESC
  title_link_ASC
  title_link_DESC
  image_url_ASC
  image_url_DESC
  asset_url_ASC
  asset_url_DESC
  thumb_url_ASC
  thumb_url_DESC
  extention_ASC
  extention_DESC
}

type AttachmentPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  type: String
  author_name: String
  title: String
  title_link: String
  image_url: String
  asset_url: String!
  thumb_url: String
  extention: String
}

input AttachmentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  author_name: String
  author_name_not: String
  author_name_in: [String!]
  author_name_not_in: [String!]
  author_name_lt: String
  author_name_lte: String
  author_name_gt: String
  author_name_gte: String
  author_name_contains: String
  author_name_not_contains: String
  author_name_starts_with: String
  author_name_not_starts_with: String
  author_name_ends_with: String
  author_name_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  title_link: String
  title_link_not: String
  title_link_in: [String!]
  title_link_not_in: [String!]
  title_link_lt: String
  title_link_lte: String
  title_link_gt: String
  title_link_gte: String
  title_link_contains: String
  title_link_not_contains: String
  title_link_starts_with: String
  title_link_not_starts_with: String
  title_link_ends_with: String
  title_link_not_ends_with: String
  image_url: String
  image_url_not: String
  image_url_in: [String!]
  image_url_not_in: [String!]
  image_url_lt: String
  image_url_lte: String
  image_url_gt: String
  image_url_gte: String
  image_url_contains: String
  image_url_not_contains: String
  image_url_starts_with: String
  image_url_not_starts_with: String
  image_url_ends_with: String
  image_url_not_ends_with: String
  asset_url: String
  asset_url_not: String
  asset_url_in: [String!]
  asset_url_not_in: [String!]
  asset_url_lt: String
  asset_url_lte: String
  asset_url_gt: String
  asset_url_gte: String
  asset_url_contains: String
  asset_url_not_contains: String
  asset_url_starts_with: String
  asset_url_not_starts_with: String
  asset_url_ends_with: String
  asset_url_not_ends_with: String
  thumb_url: String
  thumb_url_not: String
  thumb_url_in: [String!]
  thumb_url_not_in: [String!]
  thumb_url_lt: String
  thumb_url_lte: String
  thumb_url_gt: String
  thumb_url_gte: String
  thumb_url_contains: String
  thumb_url_not_contains: String
  thumb_url_starts_with: String
  thumb_url_not_starts_with: String
  thumb_url_ends_with: String
  thumb_url_not_ends_with: String
  extention: String
  extention_not: String
  extention_in: [String!]
  extention_not_in: [String!]
  extention_lt: String
  extention_lte: String
  extention_gt: String
  extention_gte: String
  extention_contains: String
  extention_not_contains: String
  extention_starts_with: String
  extention_not_starts_with: String
  extention_ends_with: String
  extention_not_ends_with: String
  AND: [AttachmentScalarWhereInput!]
  OR: [AttachmentScalarWhereInput!]
  NOT: [AttachmentScalarWhereInput!]
}

type AttachmentSubscriptionPayload {
  mutation: MutationType!
  node: Attachment
  updatedFields: [String!]
  previousValues: AttachmentPreviousValues
}

input AttachmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AttachmentWhereInput
  AND: [AttachmentSubscriptionWhereInput!]
  OR: [AttachmentSubscriptionWhereInput!]
  NOT: [AttachmentSubscriptionWhereInput!]
}

input AttachmentUpdateDataInput {
  type: String
  author_name: String
  title: String
  title_link: String
  image_url: String
  asset_url: String
  thumb_url: String
  extention: String
  author: UserUpdateOneInput
}

input AttachmentUpdateInput {
  type: String
  author_name: String
  title: String
  title_link: String
  image_url: String
  asset_url: String
  thumb_url: String
  extention: String
  author: UserUpdateOneInput
}

input AttachmentUpdateManyDataInput {
  type: String
  author_name: String
  title: String
  title_link: String
  image_url: String
  asset_url: String
  thumb_url: String
  extention: String
}

input AttachmentUpdateManyInput {
  create: [AttachmentCreateInput!]
  update: [AttachmentUpdateWithWhereUniqueNestedInput!]
  upsert: [AttachmentUpsertWithWhereUniqueNestedInput!]
  delete: [AttachmentWhereUniqueInput!]
  connect: [AttachmentWhereUniqueInput!]
  set: [AttachmentWhereUniqueInput!]
  disconnect: [AttachmentWhereUniqueInput!]
  deleteMany: [AttachmentScalarWhereInput!]
  updateMany: [AttachmentUpdateManyWithWhereNestedInput!]
}

input AttachmentUpdateManyMutationInput {
  type: String
  author_name: String
  title: String
  title_link: String
  image_url: String
  asset_url: String
  thumb_url: String
  extention: String
}

input AttachmentUpdateManyWithWhereNestedInput {
  where: AttachmentScalarWhereInput!
  data: AttachmentUpdateManyDataInput!
}

input AttachmentUpdateWithWhereUniqueNestedInput {
  where: AttachmentWhereUniqueInput!
  data: AttachmentUpdateDataInput!
}

input AttachmentUpsertWithWhereUniqueNestedInput {
  where: AttachmentWhereUniqueInput!
  update: AttachmentUpdateDataInput!
  create: AttachmentCreateInput!
}

input AttachmentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  author_name: String
  author_name_not: String
  author_name_in: [String!]
  author_name_not_in: [String!]
  author_name_lt: String
  author_name_lte: String
  author_name_gt: String
  author_name_gte: String
  author_name_contains: String
  author_name_not_contains: String
  author_name_starts_with: String
  author_name_not_starts_with: String
  author_name_ends_with: String
  author_name_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  title_link: String
  title_link_not: String
  title_link_in: [String!]
  title_link_not_in: [String!]
  title_link_lt: String
  title_link_lte: String
  title_link_gt: String
  title_link_gte: String
  title_link_contains: String
  title_link_not_contains: String
  title_link_starts_with: String
  title_link_not_starts_with: String
  title_link_ends_with: String
  title_link_not_ends_with: String
  image_url: String
  image_url_not: String
  image_url_in: [String!]
  image_url_not_in: [String!]
  image_url_lt: String
  image_url_lte: String
  image_url_gt: String
  image_url_gte: String
  image_url_contains: String
  image_url_not_contains: String
  image_url_starts_with: String
  image_url_not_starts_with: String
  image_url_ends_with: String
  image_url_not_ends_with: String
  asset_url: String
  asset_url_not: String
  asset_url_in: [String!]
  asset_url_not_in: [String!]
  asset_url_lt: String
  asset_url_lte: String
  asset_url_gt: String
  asset_url_gte: String
  asset_url_contains: String
  asset_url_not_contains: String
  asset_url_starts_with: String
  asset_url_not_starts_with: String
  asset_url_ends_with: String
  asset_url_not_ends_with: String
  thumb_url: String
  thumb_url_not: String
  thumb_url_in: [String!]
  thumb_url_not_in: [String!]
  thumb_url_lt: String
  thumb_url_lte: String
  thumb_url_gt: String
  thumb_url_gte: String
  thumb_url_contains: String
  thumb_url_not_contains: String
  thumb_url_starts_with: String
  thumb_url_not_starts_with: String
  thumb_url_ends_with: String
  thumb_url_not_ends_with: String
  extention: String
  extention_not: String
  extention_in: [String!]
  extention_not_in: [String!]
  extention_lt: String
  extention_lte: String
  extention_gt: String
  extention_gte: String
  extention_contains: String
  extention_not_contains: String
  extention_starts_with: String
  extention_not_starts_with: String
  extention_ends_with: String
  extention_not_ends_with: String
  author: UserWhereInput
  AND: [AttachmentWhereInput!]
  OR: [AttachmentWhereInput!]
  NOT: [AttachmentWhereInput!]
}

input AttachmentWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Category {
  id: ID!
  name: String
  skills(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Skill!]
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  id: ID
  name: String
  skills: SkillCreateManyInput
}

type CategoryEdge {
  node: Category!
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type CategoryPreviousValues {
  id: ID!
  name: String
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
  AND: [CategorySubscriptionWhereInput!]
  OR: [CategorySubscriptionWhereInput!]
  NOT: [CategorySubscriptionWhereInput!]
}

input CategoryUpdateInput {
  name: String
  skills: SkillUpdateManyInput
}

input CategoryUpdateManyMutationInput {
  name: String
}

input CategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  skills_every: SkillWhereInput
  skills_some: SkillWhereInput
  skills_none: SkillWhereInput
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
}

input CategoryWhereUniqueInput {
  id: ID
}

type Certification {
  id: ID!
  freelancer: Freelancer
  organization: String
  title: String
  year: String
}

type CertificationConnection {
  pageInfo: PageInfo!
  edges: [CertificationEdge]!
  aggregate: AggregateCertification!
}

input CertificationCreateInput {
  id: ID
  freelancer: FreelancerCreateOneWithoutCertificationInput
  organization: String
  title: String
  year: String
}

input CertificationCreateManyWithoutFreelancerInput {
  create: [CertificationCreateWithoutFreelancerInput!]
  connect: [CertificationWhereUniqueInput!]
}

input CertificationCreateWithoutFreelancerInput {
  id: ID
  organization: String
  title: String
  year: String
}

type CertificationEdge {
  node: Certification!
  cursor: String!
}

enum CertificationOrderByInput {
  id_ASC
  id_DESC
  organization_ASC
  organization_DESC
  title_ASC
  title_DESC
  year_ASC
  year_DESC
}

type CertificationPreviousValues {
  id: ID!
  organization: String
  title: String
  year: String
}

input CertificationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  organization: String
  organization_not: String
  organization_in: [String!]
  organization_not_in: [String!]
  organization_lt: String
  organization_lte: String
  organization_gt: String
  organization_gte: String
  organization_contains: String
  organization_not_contains: String
  organization_starts_with: String
  organization_not_starts_with: String
  organization_ends_with: String
  organization_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  year: String
  year_not: String
  year_in: [String!]
  year_not_in: [String!]
  year_lt: String
  year_lte: String
  year_gt: String
  year_gte: String
  year_contains: String
  year_not_contains: String
  year_starts_with: String
  year_not_starts_with: String
  year_ends_with: String
  year_not_ends_with: String
  AND: [CertificationScalarWhereInput!]
  OR: [CertificationScalarWhereInput!]
  NOT: [CertificationScalarWhereInput!]
}

type CertificationSubscriptionPayload {
  mutation: MutationType!
  node: Certification
  updatedFields: [String!]
  previousValues: CertificationPreviousValues
}

input CertificationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CertificationWhereInput
  AND: [CertificationSubscriptionWhereInput!]
  OR: [CertificationSubscriptionWhereInput!]
  NOT: [CertificationSubscriptionWhereInput!]
}

input CertificationUpdateInput {
  freelancer: FreelancerUpdateOneWithoutCertificationInput
  organization: String
  title: String
  year: String
}

input CertificationUpdateManyDataInput {
  organization: String
  title: String
  year: String
}

input CertificationUpdateManyMutationInput {
  organization: String
  title: String
  year: String
}

input CertificationUpdateManyWithoutFreelancerInput {
  create: [CertificationCreateWithoutFreelancerInput!]
  delete: [CertificationWhereUniqueInput!]
  connect: [CertificationWhereUniqueInput!]
  set: [CertificationWhereUniqueInput!]
  disconnect: [CertificationWhereUniqueInput!]
  update: [CertificationUpdateWithWhereUniqueWithoutFreelancerInput!]
  upsert: [CertificationUpsertWithWhereUniqueWithoutFreelancerInput!]
  deleteMany: [CertificationScalarWhereInput!]
  updateMany: [CertificationUpdateManyWithWhereNestedInput!]
}

input CertificationUpdateManyWithWhereNestedInput {
  where: CertificationScalarWhereInput!
  data: CertificationUpdateManyDataInput!
}

input CertificationUpdateWithoutFreelancerDataInput {
  organization: String
  title: String
  year: String
}

input CertificationUpdateWithWhereUniqueWithoutFreelancerInput {
  where: CertificationWhereUniqueInput!
  data: CertificationUpdateWithoutFreelancerDataInput!
}

input CertificationUpsertWithWhereUniqueWithoutFreelancerInput {
  where: CertificationWhereUniqueInput!
  update: CertificationUpdateWithoutFreelancerDataInput!
  create: CertificationCreateWithoutFreelancerInput!
}

input CertificationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  freelancer: FreelancerWhereInput
  organization: String
  organization_not: String
  organization_in: [String!]
  organization_not_in: [String!]
  organization_lt: String
  organization_lte: String
  organization_gt: String
  organization_gte: String
  organization_contains: String
  organization_not_contains: String
  organization_starts_with: String
  organization_not_starts_with: String
  organization_ends_with: String
  organization_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  year: String
  year_not: String
  year_in: [String!]
  year_not_in: [String!]
  year_lt: String
  year_lte: String
  year_gt: String
  year_gte: String
  year_contains: String
  year_not_contains: String
  year_starts_with: String
  year_not_starts_with: String
  year_ends_with: String
  year_not_ends_with: String
  AND: [CertificationWhereInput!]
  OR: [CertificationWhereInput!]
  NOT: [CertificationWhereInput!]
}

input CertificationWhereUniqueInput {
  id: ID
}

type Company {
  id: ID!
  employer: Employer
  description: String
  name: String
  website: String
}

type CompanyConnection {
  pageInfo: PageInfo!
  edges: [CompanyEdge]!
  aggregate: AggregateCompany!
}

input CompanyCreateInput {
  id: ID
  employer: EmployerCreateOneWithoutCompanyInput
  description: String
  name: String
  website: String
}

input CompanyCreateOneWithoutEmployerInput {
  create: CompanyCreateWithoutEmployerInput
  connect: CompanyWhereUniqueInput
}

input CompanyCreateWithoutEmployerInput {
  id: ID
  description: String
  name: String
  website: String
}

type CompanyEdge {
  node: Company!
  cursor: String!
}

enum CompanyOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  name_ASC
  name_DESC
  website_ASC
  website_DESC
}

type CompanyPreviousValues {
  id: ID!
  description: String
  name: String
  website: String
}

type CompanySubscriptionPayload {
  mutation: MutationType!
  node: Company
  updatedFields: [String!]
  previousValues: CompanyPreviousValues
}

input CompanySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CompanyWhereInput
  AND: [CompanySubscriptionWhereInput!]
  OR: [CompanySubscriptionWhereInput!]
  NOT: [CompanySubscriptionWhereInput!]
}

input CompanyUpdateInput {
  employer: EmployerUpdateOneWithoutCompanyInput
  description: String
  name: String
  website: String
}

input CompanyUpdateManyMutationInput {
  description: String
  name: String
  website: String
}

input CompanyUpdateOneWithoutEmployerInput {
  create: CompanyCreateWithoutEmployerInput
  update: CompanyUpdateWithoutEmployerDataInput
  upsert: CompanyUpsertWithoutEmployerInput
  delete: Boolean
  disconnect: Boolean
  connect: CompanyWhereUniqueInput
}

input CompanyUpdateWithoutEmployerDataInput {
  description: String
  name: String
  website: String
}

input CompanyUpsertWithoutEmployerInput {
  update: CompanyUpdateWithoutEmployerDataInput!
  create: CompanyCreateWithoutEmployerInput!
}

input CompanyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  employer: EmployerWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  website: String
  website_not: String
  website_in: [String!]
  website_not_in: [String!]
  website_lt: String
  website_lte: String
  website_gt: String
  website_gte: String
  website_contains: String
  website_not_contains: String
  website_starts_with: String
  website_not_starts_with: String
  website_ends_with: String
  website_not_ends_with: String
  AND: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  NOT: [CompanyWhereInput!]
}

input CompanyWhereUniqueInput {
  id: ID
}

type Contact {
  id: ID!
  employer: Employer
  country: String
  owner: String
  phone: String
  timeZone: String
  address: String
}

type ContactConnection {
  pageInfo: PageInfo!
  edges: [ContactEdge]!
  aggregate: AggregateContact!
}

input ContactCreateInput {
  id: ID
  employer: EmployerCreateOneWithoutContactInput
  country: String
  owner: String
  phone: String
  timeZone: String
  address: String
}

input ContactCreateOneWithoutEmployerInput {
  create: ContactCreateWithoutEmployerInput
  connect: ContactWhereUniqueInput
}

input ContactCreateWithoutEmployerInput {
  id: ID
  country: String
  owner: String
  phone: String
  timeZone: String
  address: String
}

type ContactEdge {
  node: Contact!
  cursor: String!
}

enum ContactOrderByInput {
  id_ASC
  id_DESC
  country_ASC
  country_DESC
  owner_ASC
  owner_DESC
  phone_ASC
  phone_DESC
  timeZone_ASC
  timeZone_DESC
  address_ASC
  address_DESC
}

type ContactPreviousValues {
  id: ID!
  country: String
  owner: String
  phone: String
  timeZone: String
  address: String
}

type ContactSubscriptionPayload {
  mutation: MutationType!
  node: Contact
  updatedFields: [String!]
  previousValues: ContactPreviousValues
}

input ContactSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContactWhereInput
  AND: [ContactSubscriptionWhereInput!]
  OR: [ContactSubscriptionWhereInput!]
  NOT: [ContactSubscriptionWhereInput!]
}

input ContactUpdateInput {
  employer: EmployerUpdateOneWithoutContactInput
  country: String
  owner: String
  phone: String
  timeZone: String
  address: String
}

input ContactUpdateManyMutationInput {
  country: String
  owner: String
  phone: String
  timeZone: String
  address: String
}

input ContactUpdateOneWithoutEmployerInput {
  create: ContactCreateWithoutEmployerInput
  update: ContactUpdateWithoutEmployerDataInput
  upsert: ContactUpsertWithoutEmployerInput
  delete: Boolean
  disconnect: Boolean
  connect: ContactWhereUniqueInput
}

input ContactUpdateWithoutEmployerDataInput {
  country: String
  owner: String
  phone: String
  timeZone: String
  address: String
}

input ContactUpsertWithoutEmployerInput {
  update: ContactUpdateWithoutEmployerDataInput!
  create: ContactCreateWithoutEmployerInput!
}

input ContactWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  employer: EmployerWhereInput
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  owner: String
  owner_not: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_gt: String
  owner_gte: String
  owner_contains: String
  owner_not_contains: String
  owner_starts_with: String
  owner_not_starts_with: String
  owner_ends_with: String
  owner_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  timeZone: String
  timeZone_not: String
  timeZone_in: [String!]
  timeZone_not_in: [String!]
  timeZone_lt: String
  timeZone_lte: String
  timeZone_gt: String
  timeZone_gte: String
  timeZone_contains: String
  timeZone_not_contains: String
  timeZone_starts_with: String
  timeZone_not_starts_with: String
  timeZone_ends_with: String
  timeZone_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  AND: [ContactWhereInput!]
  OR: [ContactWhereInput!]
  NOT: [ContactWhereInput!]
}

input ContactWhereUniqueInput {
  id: ID
}

type Conversation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  name: String!
  isGroup: Boolean
  texts(where: TextWhereInput, orderBy: TextOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Text!]
  participants(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
}

type ConversationConnection {
  pageInfo: PageInfo!
  edges: [ConversationEdge]!
  aggregate: AggregateConversation!
}

input ConversationCreateInput {
  id: ID
  name: String!
  isGroup: Boolean
  texts: TextCreateManyWithoutConversationInput
  participants: UserCreateManyWithoutConversationsInput
}

input ConversationCreateManyWithoutParticipantsInput {
  create: [ConversationCreateWithoutParticipantsInput!]
  connect: [ConversationWhereUniqueInput!]
}

input ConversationCreateOneInput {
  create: ConversationCreateInput
  connect: ConversationWhereUniqueInput
}

input ConversationCreateOneWithoutTextsInput {
  create: ConversationCreateWithoutTextsInput
  connect: ConversationWhereUniqueInput
}

input ConversationCreateWithoutParticipantsInput {
  id: ID
  name: String!
  isGroup: Boolean
  texts: TextCreateManyWithoutConversationInput
}

input ConversationCreateWithoutTextsInput {
  id: ID
  name: String!
  isGroup: Boolean
  participants: UserCreateManyWithoutConversationsInput
}

type ConversationEdge {
  node: Conversation!
  cursor: String!
}

enum ConversationOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  isGroup_ASC
  isGroup_DESC
}

type ConversationPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  name: String!
  isGroup: Boolean
}

input ConversationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  isGroup: Boolean
  isGroup_not: Boolean
  AND: [ConversationScalarWhereInput!]
  OR: [ConversationScalarWhereInput!]
  NOT: [ConversationScalarWhereInput!]
}

type ConversationSubscriptionPayload {
  mutation: MutationType!
  node: Conversation
  updatedFields: [String!]
  previousValues: ConversationPreviousValues
}

input ConversationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ConversationWhereInput
  AND: [ConversationSubscriptionWhereInput!]
  OR: [ConversationSubscriptionWhereInput!]
  NOT: [ConversationSubscriptionWhereInput!]
}

input ConversationUpdateDataInput {
  name: String
  isGroup: Boolean
  texts: TextUpdateManyWithoutConversationInput
  participants: UserUpdateManyWithoutConversationsInput
}

input ConversationUpdateInput {
  name: String
  isGroup: Boolean
  texts: TextUpdateManyWithoutConversationInput
  participants: UserUpdateManyWithoutConversationsInput
}

input ConversationUpdateManyDataInput {
  name: String
  isGroup: Boolean
}

input ConversationUpdateManyMutationInput {
  name: String
  isGroup: Boolean
}

input ConversationUpdateManyWithoutParticipantsInput {
  create: [ConversationCreateWithoutParticipantsInput!]
  delete: [ConversationWhereUniqueInput!]
  connect: [ConversationWhereUniqueInput!]
  set: [ConversationWhereUniqueInput!]
  disconnect: [ConversationWhereUniqueInput!]
  update: [ConversationUpdateWithWhereUniqueWithoutParticipantsInput!]
  upsert: [ConversationUpsertWithWhereUniqueWithoutParticipantsInput!]
  deleteMany: [ConversationScalarWhereInput!]
  updateMany: [ConversationUpdateManyWithWhereNestedInput!]
}

input ConversationUpdateManyWithWhereNestedInput {
  where: ConversationScalarWhereInput!
  data: ConversationUpdateManyDataInput!
}

input ConversationUpdateOneInput {
  create: ConversationCreateInput
  update: ConversationUpdateDataInput
  upsert: ConversationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ConversationWhereUniqueInput
}

input ConversationUpdateOneRequiredWithoutTextsInput {
  create: ConversationCreateWithoutTextsInput
  update: ConversationUpdateWithoutTextsDataInput
  upsert: ConversationUpsertWithoutTextsInput
  connect: ConversationWhereUniqueInput
}

input ConversationUpdateWithoutParticipantsDataInput {
  name: String
  isGroup: Boolean
  texts: TextUpdateManyWithoutConversationInput
}

input ConversationUpdateWithoutTextsDataInput {
  name: String
  isGroup: Boolean
  participants: UserUpdateManyWithoutConversationsInput
}

input ConversationUpdateWithWhereUniqueWithoutParticipantsInput {
  where: ConversationWhereUniqueInput!
  data: ConversationUpdateWithoutParticipantsDataInput!
}

input ConversationUpsertNestedInput {
  update: ConversationUpdateDataInput!
  create: ConversationCreateInput!
}

input ConversationUpsertWithoutTextsInput {
  update: ConversationUpdateWithoutTextsDataInput!
  create: ConversationCreateWithoutTextsInput!
}

input ConversationUpsertWithWhereUniqueWithoutParticipantsInput {
  where: ConversationWhereUniqueInput!
  update: ConversationUpdateWithoutParticipantsDataInput!
  create: ConversationCreateWithoutParticipantsInput!
}

input ConversationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  isGroup: Boolean
  isGroup_not: Boolean
  texts_every: TextWhereInput
  texts_some: TextWhereInput
  texts_none: TextWhereInput
  participants_every: UserWhereInput
  participants_some: UserWhereInput
  participants_none: UserWhereInput
  AND: [ConversationWhereInput!]
  OR: [ConversationWhereInput!]
  NOT: [ConversationWhereInput!]
}

input ConversationWhereUniqueInput {
  id: ID
}

scalar DateTime

type Education {
  id: ID!
  freelancer: Freelancer
  degree: String
  schoolName: String
  yearFinal: String
  yearStart: String
}

type EducationConnection {
  pageInfo: PageInfo!
  edges: [EducationEdge]!
  aggregate: AggregateEducation!
}

input EducationCreateInput {
  id: ID
  freelancer: FreelancerCreateOneWithoutEducationInput
  degree: String
  schoolName: String
  yearFinal: String
  yearStart: String
}

input EducationCreateManyWithoutFreelancerInput {
  create: [EducationCreateWithoutFreelancerInput!]
  connect: [EducationWhereUniqueInput!]
}

input EducationCreateWithoutFreelancerInput {
  id: ID
  degree: String
  schoolName: String
  yearFinal: String
  yearStart: String
}

type EducationEdge {
  node: Education!
  cursor: String!
}

enum EducationOrderByInput {
  id_ASC
  id_DESC
  degree_ASC
  degree_DESC
  schoolName_ASC
  schoolName_DESC
  yearFinal_ASC
  yearFinal_DESC
  yearStart_ASC
  yearStart_DESC
}

type EducationPreviousValues {
  id: ID!
  degree: String
  schoolName: String
  yearFinal: String
  yearStart: String
}

input EducationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  degree: String
  degree_not: String
  degree_in: [String!]
  degree_not_in: [String!]
  degree_lt: String
  degree_lte: String
  degree_gt: String
  degree_gte: String
  degree_contains: String
  degree_not_contains: String
  degree_starts_with: String
  degree_not_starts_with: String
  degree_ends_with: String
  degree_not_ends_with: String
  schoolName: String
  schoolName_not: String
  schoolName_in: [String!]
  schoolName_not_in: [String!]
  schoolName_lt: String
  schoolName_lte: String
  schoolName_gt: String
  schoolName_gte: String
  schoolName_contains: String
  schoolName_not_contains: String
  schoolName_starts_with: String
  schoolName_not_starts_with: String
  schoolName_ends_with: String
  schoolName_not_ends_with: String
  yearFinal: String
  yearFinal_not: String
  yearFinal_in: [String!]
  yearFinal_not_in: [String!]
  yearFinal_lt: String
  yearFinal_lte: String
  yearFinal_gt: String
  yearFinal_gte: String
  yearFinal_contains: String
  yearFinal_not_contains: String
  yearFinal_starts_with: String
  yearFinal_not_starts_with: String
  yearFinal_ends_with: String
  yearFinal_not_ends_with: String
  yearStart: String
  yearStart_not: String
  yearStart_in: [String!]
  yearStart_not_in: [String!]
  yearStart_lt: String
  yearStart_lte: String
  yearStart_gt: String
  yearStart_gte: String
  yearStart_contains: String
  yearStart_not_contains: String
  yearStart_starts_with: String
  yearStart_not_starts_with: String
  yearStart_ends_with: String
  yearStart_not_ends_with: String
  AND: [EducationScalarWhereInput!]
  OR: [EducationScalarWhereInput!]
  NOT: [EducationScalarWhereInput!]
}

type EducationSubscriptionPayload {
  mutation: MutationType!
  node: Education
  updatedFields: [String!]
  previousValues: EducationPreviousValues
}

input EducationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EducationWhereInput
  AND: [EducationSubscriptionWhereInput!]
  OR: [EducationSubscriptionWhereInput!]
  NOT: [EducationSubscriptionWhereInput!]
}

input EducationUpdateInput {
  freelancer: FreelancerUpdateOneWithoutEducationInput
  degree: String
  schoolName: String
  yearFinal: String
  yearStart: String
}

input EducationUpdateManyDataInput {
  degree: String
  schoolName: String
  yearFinal: String
  yearStart: String
}

input EducationUpdateManyMutationInput {
  degree: String
  schoolName: String
  yearFinal: String
  yearStart: String
}

input EducationUpdateManyWithoutFreelancerInput {
  create: [EducationCreateWithoutFreelancerInput!]
  delete: [EducationWhereUniqueInput!]
  connect: [EducationWhereUniqueInput!]
  set: [EducationWhereUniqueInput!]
  disconnect: [EducationWhereUniqueInput!]
  update: [EducationUpdateWithWhereUniqueWithoutFreelancerInput!]
  upsert: [EducationUpsertWithWhereUniqueWithoutFreelancerInput!]
  deleteMany: [EducationScalarWhereInput!]
  updateMany: [EducationUpdateManyWithWhereNestedInput!]
}

input EducationUpdateManyWithWhereNestedInput {
  where: EducationScalarWhereInput!
  data: EducationUpdateManyDataInput!
}

input EducationUpdateWithoutFreelancerDataInput {
  degree: String
  schoolName: String
  yearFinal: String
  yearStart: String
}

input EducationUpdateWithWhereUniqueWithoutFreelancerInput {
  where: EducationWhereUniqueInput!
  data: EducationUpdateWithoutFreelancerDataInput!
}

input EducationUpsertWithWhereUniqueWithoutFreelancerInput {
  where: EducationWhereUniqueInput!
  update: EducationUpdateWithoutFreelancerDataInput!
  create: EducationCreateWithoutFreelancerInput!
}

input EducationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  freelancer: FreelancerWhereInput
  degree: String
  degree_not: String
  degree_in: [String!]
  degree_not_in: [String!]
  degree_lt: String
  degree_lte: String
  degree_gt: String
  degree_gte: String
  degree_contains: String
  degree_not_contains: String
  degree_starts_with: String
  degree_not_starts_with: String
  degree_ends_with: String
  degree_not_ends_with: String
  schoolName: String
  schoolName_not: String
  schoolName_in: [String!]
  schoolName_not_in: [String!]
  schoolName_lt: String
  schoolName_lte: String
  schoolName_gt: String
  schoolName_gte: String
  schoolName_contains: String
  schoolName_not_contains: String
  schoolName_starts_with: String
  schoolName_not_starts_with: String
  schoolName_ends_with: String
  schoolName_not_ends_with: String
  yearFinal: String
  yearFinal_not: String
  yearFinal_in: [String!]
  yearFinal_not_in: [String!]
  yearFinal_lt: String
  yearFinal_lte: String
  yearFinal_gt: String
  yearFinal_gte: String
  yearFinal_contains: String
  yearFinal_not_contains: String
  yearFinal_starts_with: String
  yearFinal_not_starts_with: String
  yearFinal_ends_with: String
  yearFinal_not_ends_with: String
  yearStart: String
  yearStart_not: String
  yearStart_in: [String!]
  yearStart_not_in: [String!]
  yearStart_lt: String
  yearStart_lte: String
  yearStart_gt: String
  yearStart_gte: String
  yearStart_contains: String
  yearStart_not_contains: String
  yearStart_starts_with: String
  yearStart_not_starts_with: String
  yearStart_ends_with: String
  yearStart_not_ends_with: String
  AND: [EducationWhereInput!]
  OR: [EducationWhereInput!]
  NOT: [EducationWhereInput!]
}

input EducationWhereUniqueInput {
  id: ID
}

type Employer {
  id: ID!
  user: User
  job(where: JobWhereInput, orderBy: JobOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Job!]
  status: String
  isDeleted: Boolean
  company: Company
  contact: Contact
  createdAt: DateTime
  updatedAt: DateTime
  tags: [String!]!
}

type EmployerConnection {
  pageInfo: PageInfo!
  edges: [EmployerEdge]!
  aggregate: AggregateEmployer!
}

input EmployerCreateInput {
  id: ID
  user: UserCreateOneWithoutEmployerInput
  job: JobCreateManyWithoutEmployerInput
  status: String
  isDeleted: Boolean
  company: CompanyCreateOneWithoutEmployerInput
  contact: ContactCreateOneWithoutEmployerInput
  tags: EmployerCreatetagsInput
}

input EmployerCreateOneInput {
  create: EmployerCreateInput
  connect: EmployerWhereUniqueInput
}

input EmployerCreateOneWithoutCompanyInput {
  create: EmployerCreateWithoutCompanyInput
  connect: EmployerWhereUniqueInput
}

input EmployerCreateOneWithoutContactInput {
  create: EmployerCreateWithoutContactInput
  connect: EmployerWhereUniqueInput
}

input EmployerCreateOneWithoutJobInput {
  create: EmployerCreateWithoutJobInput
  connect: EmployerWhereUniqueInput
}

input EmployerCreateOneWithoutUserInput {
  create: EmployerCreateWithoutUserInput
  connect: EmployerWhereUniqueInput
}

input EmployerCreatetagsInput {
  set: [String!]
}

input EmployerCreateWithoutCompanyInput {
  id: ID
  user: UserCreateOneWithoutEmployerInput
  job: JobCreateManyWithoutEmployerInput
  status: String
  isDeleted: Boolean
  contact: ContactCreateOneWithoutEmployerInput
  tags: EmployerCreatetagsInput
}

input EmployerCreateWithoutContactInput {
  id: ID
  user: UserCreateOneWithoutEmployerInput
  job: JobCreateManyWithoutEmployerInput
  status: String
  isDeleted: Boolean
  company: CompanyCreateOneWithoutEmployerInput
  tags: EmployerCreatetagsInput
}

input EmployerCreateWithoutJobInput {
  id: ID
  user: UserCreateOneWithoutEmployerInput
  status: String
  isDeleted: Boolean
  company: CompanyCreateOneWithoutEmployerInput
  contact: ContactCreateOneWithoutEmployerInput
  tags: EmployerCreatetagsInput
}

input EmployerCreateWithoutUserInput {
  id: ID
  job: JobCreateManyWithoutEmployerInput
  status: String
  isDeleted: Boolean
  company: CompanyCreateOneWithoutEmployerInput
  contact: ContactCreateOneWithoutEmployerInput
  tags: EmployerCreatetagsInput
}

type EmployerEdge {
  node: Employer!
  cursor: String!
}

type employerInvitedFreelancer {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  freelancer: Freelancer
  job: Job
  message: String
}

type employerInvitedFreelancerConnection {
  pageInfo: PageInfo!
  edges: [employerInvitedFreelancerEdge]!
  aggregate: AggregateemployerInvitedFreelancer!
}

input employerInvitedFreelancerCreateInput {
  id: ID
  freelancer: FreelancerCreateOneInput
  job: JobCreateOneInput
  message: String
}

type employerInvitedFreelancerEdge {
  node: employerInvitedFreelancer!
  cursor: String!
}

enum employerInvitedFreelancerOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  message_ASC
  message_DESC
}

type employerInvitedFreelancerPreviousValues {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  message: String
}

type employerInvitedFreelancerSubscriptionPayload {
  mutation: MutationType!
  node: employerInvitedFreelancer
  updatedFields: [String!]
  previousValues: employerInvitedFreelancerPreviousValues
}

input employerInvitedFreelancerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: employerInvitedFreelancerWhereInput
  AND: [employerInvitedFreelancerSubscriptionWhereInput!]
  OR: [employerInvitedFreelancerSubscriptionWhereInput!]
  NOT: [employerInvitedFreelancerSubscriptionWhereInput!]
}

input employerInvitedFreelancerUpdateInput {
  freelancer: FreelancerUpdateOneInput
  job: JobUpdateOneInput
  message: String
}

input employerInvitedFreelancerUpdateManyMutationInput {
  message: String
}

input employerInvitedFreelancerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  freelancer: FreelancerWhereInput
  job: JobWhereInput
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  AND: [employerInvitedFreelancerWhereInput!]
  OR: [employerInvitedFreelancerWhereInput!]
  NOT: [employerInvitedFreelancerWhereInput!]
}

input employerInvitedFreelancerWhereUniqueInput {
  id: ID
}

enum EmployerOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EmployerPreviousValues {
  id: ID!
  status: String
  isDeleted: Boolean
  createdAt: DateTime
  updatedAt: DateTime
  tags: [String!]!
}

type EmployerShortList {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  freelancer: Freelancer
  job: Job
  employer: Employer
  isOffer: Boolean
  isArchived: Boolean
}

type EmployerShortListConnection {
  pageInfo: PageInfo!
  edges: [EmployerShortListEdge]!
  aggregate: AggregateEmployerShortList!
}

input EmployerShortListCreateInput {
  id: ID
  freelancer: FreelancerCreateOneInput
  job: JobCreateOneInput
  employer: EmployerCreateOneInput
  isOffer: Boolean
  isArchived: Boolean
}

type EmployerShortListEdge {
  node: EmployerShortList!
  cursor: String!
}

enum EmployerShortListOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  isOffer_ASC
  isOffer_DESC
  isArchived_ASC
  isArchived_DESC
}

type EmployerShortListPreviousValues {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  isOffer: Boolean
  isArchived: Boolean
}

type EmployerShortListSubscriptionPayload {
  mutation: MutationType!
  node: EmployerShortList
  updatedFields: [String!]
  previousValues: EmployerShortListPreviousValues
}

input EmployerShortListSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EmployerShortListWhereInput
  AND: [EmployerShortListSubscriptionWhereInput!]
  OR: [EmployerShortListSubscriptionWhereInput!]
  NOT: [EmployerShortListSubscriptionWhereInput!]
}

input EmployerShortListUpdateInput {
  freelancer: FreelancerUpdateOneInput
  job: JobUpdateOneInput
  employer: EmployerUpdateOneInput
  isOffer: Boolean
  isArchived: Boolean
}

input EmployerShortListUpdateManyMutationInput {
  isOffer: Boolean
  isArchived: Boolean
}

input EmployerShortListWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  freelancer: FreelancerWhereInput
  job: JobWhereInput
  employer: EmployerWhereInput
  isOffer: Boolean
  isOffer_not: Boolean
  isArchived: Boolean
  isArchived_not: Boolean
  AND: [EmployerShortListWhereInput!]
  OR: [EmployerShortListWhereInput!]
  NOT: [EmployerShortListWhereInput!]
}

input EmployerShortListWhereUniqueInput {
  id: ID
}

type EmployerSubscriptionPayload {
  mutation: MutationType!
  node: Employer
  updatedFields: [String!]
  previousValues: EmployerPreviousValues
}

input EmployerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EmployerWhereInput
  AND: [EmployerSubscriptionWhereInput!]
  OR: [EmployerSubscriptionWhereInput!]
  NOT: [EmployerSubscriptionWhereInput!]
}

input EmployerUpdateDataInput {
  user: UserUpdateOneWithoutEmployerInput
  job: JobUpdateManyWithoutEmployerInput
  status: String
  isDeleted: Boolean
  company: CompanyUpdateOneWithoutEmployerInput
  contact: ContactUpdateOneWithoutEmployerInput
  tags: EmployerUpdatetagsInput
}

input EmployerUpdateInput {
  user: UserUpdateOneWithoutEmployerInput
  job: JobUpdateManyWithoutEmployerInput
  status: String
  isDeleted: Boolean
  company: CompanyUpdateOneWithoutEmployerInput
  contact: ContactUpdateOneWithoutEmployerInput
  tags: EmployerUpdatetagsInput
}

input EmployerUpdateManyMutationInput {
  status: String
  isDeleted: Boolean
  tags: EmployerUpdatetagsInput
}

input EmployerUpdateOneInput {
  create: EmployerCreateInput
  update: EmployerUpdateDataInput
  upsert: EmployerUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: EmployerWhereUniqueInput
}

input EmployerUpdateOneWithoutCompanyInput {
  create: EmployerCreateWithoutCompanyInput
  update: EmployerUpdateWithoutCompanyDataInput
  upsert: EmployerUpsertWithoutCompanyInput
  delete: Boolean
  disconnect: Boolean
  connect: EmployerWhereUniqueInput
}

input EmployerUpdateOneWithoutContactInput {
  create: EmployerCreateWithoutContactInput
  update: EmployerUpdateWithoutContactDataInput
  upsert: EmployerUpsertWithoutContactInput
  delete: Boolean
  disconnect: Boolean
  connect: EmployerWhereUniqueInput
}

input EmployerUpdateOneWithoutJobInput {
  create: EmployerCreateWithoutJobInput
  update: EmployerUpdateWithoutJobDataInput
  upsert: EmployerUpsertWithoutJobInput
  delete: Boolean
  disconnect: Boolean
  connect: EmployerWhereUniqueInput
}

input EmployerUpdateOneWithoutUserInput {
  create: EmployerCreateWithoutUserInput
  update: EmployerUpdateWithoutUserDataInput
  upsert: EmployerUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  connect: EmployerWhereUniqueInput
}

input EmployerUpdatetagsInput {
  set: [String!]
}

input EmployerUpdateWithoutCompanyDataInput {
  user: UserUpdateOneWithoutEmployerInput
  job: JobUpdateManyWithoutEmployerInput
  status: String
  isDeleted: Boolean
  contact: ContactUpdateOneWithoutEmployerInput
  tags: EmployerUpdatetagsInput
}

input EmployerUpdateWithoutContactDataInput {
  user: UserUpdateOneWithoutEmployerInput
  job: JobUpdateManyWithoutEmployerInput
  status: String
  isDeleted: Boolean
  company: CompanyUpdateOneWithoutEmployerInput
  tags: EmployerUpdatetagsInput
}

input EmployerUpdateWithoutJobDataInput {
  user: UserUpdateOneWithoutEmployerInput
  status: String
  isDeleted: Boolean
  company: CompanyUpdateOneWithoutEmployerInput
  contact: ContactUpdateOneWithoutEmployerInput
  tags: EmployerUpdatetagsInput
}

input EmployerUpdateWithoutUserDataInput {
  job: JobUpdateManyWithoutEmployerInput
  status: String
  isDeleted: Boolean
  company: CompanyUpdateOneWithoutEmployerInput
  contact: ContactUpdateOneWithoutEmployerInput
  tags: EmployerUpdatetagsInput
}

input EmployerUpsertNestedInput {
  update: EmployerUpdateDataInput!
  create: EmployerCreateInput!
}

input EmployerUpsertWithoutCompanyInput {
  update: EmployerUpdateWithoutCompanyDataInput!
  create: EmployerCreateWithoutCompanyInput!
}

input EmployerUpsertWithoutContactInput {
  update: EmployerUpdateWithoutContactDataInput!
  create: EmployerCreateWithoutContactInput!
}

input EmployerUpsertWithoutJobInput {
  update: EmployerUpdateWithoutJobDataInput!
  create: EmployerCreateWithoutJobInput!
}

input EmployerUpsertWithoutUserInput {
  update: EmployerUpdateWithoutUserDataInput!
  create: EmployerCreateWithoutUserInput!
}

input EmployerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  job_every: JobWhereInput
  job_some: JobWhereInput
  job_none: JobWhereInput
  status: String
  status_not: String
  status_in: [String!]
  status_not_in: [String!]
  status_lt: String
  status_lte: String
  status_gt: String
  status_gte: String
  status_contains: String
  status_not_contains: String
  status_starts_with: String
  status_not_starts_with: String
  status_ends_with: String
  status_not_ends_with: String
  isDeleted: Boolean
  isDeleted_not: Boolean
  company: CompanyWhereInput
  contact: ContactWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [EmployerWhereInput!]
  OR: [EmployerWhereInput!]
  NOT: [EmployerWhereInput!]
}

input EmployerWhereUniqueInput {
  id: ID
}

type Experience {
  id: ID!
  freelancer: Freelancer
  description: String
  location: String
  timeEnd: String
  timeStart: String
  tittle: String
}

type ExperienceConnection {
  pageInfo: PageInfo!
  edges: [ExperienceEdge]!
  aggregate: AggregateExperience!
}

input ExperienceCreateInput {
  id: ID
  freelancer: FreelancerCreateOneWithoutExperiencesInput
  description: String
  location: String
  timeEnd: String
  timeStart: String
  tittle: String
}

input ExperienceCreateManyWithoutFreelancerInput {
  create: [ExperienceCreateWithoutFreelancerInput!]
  connect: [ExperienceWhereUniqueInput!]
}

input ExperienceCreateWithoutFreelancerInput {
  id: ID
  description: String
  location: String
  timeEnd: String
  timeStart: String
  tittle: String
}

type ExperienceEdge {
  node: Experience!
  cursor: String!
}

enum ExperienceOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  location_ASC
  location_DESC
  timeEnd_ASC
  timeEnd_DESC
  timeStart_ASC
  timeStart_DESC
  tittle_ASC
  tittle_DESC
}

type ExperiencePreviousValues {
  id: ID!
  description: String
  location: String
  timeEnd: String
  timeStart: String
  tittle: String
}

input ExperienceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  timeEnd: String
  timeEnd_not: String
  timeEnd_in: [String!]
  timeEnd_not_in: [String!]
  timeEnd_lt: String
  timeEnd_lte: String
  timeEnd_gt: String
  timeEnd_gte: String
  timeEnd_contains: String
  timeEnd_not_contains: String
  timeEnd_starts_with: String
  timeEnd_not_starts_with: String
  timeEnd_ends_with: String
  timeEnd_not_ends_with: String
  timeStart: String
  timeStart_not: String
  timeStart_in: [String!]
  timeStart_not_in: [String!]
  timeStart_lt: String
  timeStart_lte: String
  timeStart_gt: String
  timeStart_gte: String
  timeStart_contains: String
  timeStart_not_contains: String
  timeStart_starts_with: String
  timeStart_not_starts_with: String
  timeStart_ends_with: String
  timeStart_not_ends_with: String
  tittle: String
  tittle_not: String
  tittle_in: [String!]
  tittle_not_in: [String!]
  tittle_lt: String
  tittle_lte: String
  tittle_gt: String
  tittle_gte: String
  tittle_contains: String
  tittle_not_contains: String
  tittle_starts_with: String
  tittle_not_starts_with: String
  tittle_ends_with: String
  tittle_not_ends_with: String
  AND: [ExperienceScalarWhereInput!]
  OR: [ExperienceScalarWhereInput!]
  NOT: [ExperienceScalarWhereInput!]
}

type ExperienceSubscriptionPayload {
  mutation: MutationType!
  node: Experience
  updatedFields: [String!]
  previousValues: ExperiencePreviousValues
}

input ExperienceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExperienceWhereInput
  AND: [ExperienceSubscriptionWhereInput!]
  OR: [ExperienceSubscriptionWhereInput!]
  NOT: [ExperienceSubscriptionWhereInput!]
}

input ExperienceUpdateInput {
  freelancer: FreelancerUpdateOneWithoutExperiencesInput
  description: String
  location: String
  timeEnd: String
  timeStart: String
  tittle: String
}

input ExperienceUpdateManyDataInput {
  description: String
  location: String
  timeEnd: String
  timeStart: String
  tittle: String
}

input ExperienceUpdateManyMutationInput {
  description: String
  location: String
  timeEnd: String
  timeStart: String
  tittle: String
}

input ExperienceUpdateManyWithoutFreelancerInput {
  create: [ExperienceCreateWithoutFreelancerInput!]
  delete: [ExperienceWhereUniqueInput!]
  connect: [ExperienceWhereUniqueInput!]
  set: [ExperienceWhereUniqueInput!]
  disconnect: [ExperienceWhereUniqueInput!]
  update: [ExperienceUpdateWithWhereUniqueWithoutFreelancerInput!]
  upsert: [ExperienceUpsertWithWhereUniqueWithoutFreelancerInput!]
  deleteMany: [ExperienceScalarWhereInput!]
  updateMany: [ExperienceUpdateManyWithWhereNestedInput!]
}

input ExperienceUpdateManyWithWhereNestedInput {
  where: ExperienceScalarWhereInput!
  data: ExperienceUpdateManyDataInput!
}

input ExperienceUpdateWithoutFreelancerDataInput {
  description: String
  location: String
  timeEnd: String
  timeStart: String
  tittle: String
}

input ExperienceUpdateWithWhereUniqueWithoutFreelancerInput {
  where: ExperienceWhereUniqueInput!
  data: ExperienceUpdateWithoutFreelancerDataInput!
}

input ExperienceUpsertWithWhereUniqueWithoutFreelancerInput {
  where: ExperienceWhereUniqueInput!
  update: ExperienceUpdateWithoutFreelancerDataInput!
  create: ExperienceCreateWithoutFreelancerInput!
}

input ExperienceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  freelancer: FreelancerWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  timeEnd: String
  timeEnd_not: String
  timeEnd_in: [String!]
  timeEnd_not_in: [String!]
  timeEnd_lt: String
  timeEnd_lte: String
  timeEnd_gt: String
  timeEnd_gte: String
  timeEnd_contains: String
  timeEnd_not_contains: String
  timeEnd_starts_with: String
  timeEnd_not_starts_with: String
  timeEnd_ends_with: String
  timeEnd_not_ends_with: String
  timeStart: String
  timeStart_not: String
  timeStart_in: [String!]
  timeStart_not_in: [String!]
  timeStart_lt: String
  timeStart_lte: String
  timeStart_gt: String
  timeStart_gte: String
  timeStart_contains: String
  timeStart_not_contains: String
  timeStart_starts_with: String
  timeStart_not_starts_with: String
  timeStart_ends_with: String
  timeStart_not_ends_with: String
  tittle: String
  tittle_not: String
  tittle_in: [String!]
  tittle_not_in: [String!]
  tittle_lt: String
  tittle_lte: String
  tittle_gt: String
  tittle_gte: String
  tittle_contains: String
  tittle_not_contains: String
  tittle_starts_with: String
  tittle_not_starts_with: String
  tittle_ends_with: String
  tittle_not_ends_with: String
  AND: [ExperienceWhereInput!]
  OR: [ExperienceWhereInput!]
  NOT: [ExperienceWhereInput!]
}

input ExperienceWhereUniqueInput {
  id: ID
}

type Freelancer {
  id: ID!
  user: User
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Skill!]
  education(where: EducationWhereInput, orderBy: EducationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Education!]
  location: String
  languageSkills(where: LanguageSkillWhereInput, orderBy: LanguageSkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LanguageSkill!]
  experiences(where: ExperienceWhereInput, orderBy: ExperienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Experience!]
  portfolio(where: PortfolioWhereInput, orderBy: PortfolioOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Portfolio!]
  certification(where: CertificationWhereInput, orderBy: CertificationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Certification!]
  publications(where: PublicationWhereInput, orderBy: PublicationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Publication!]
  tags: [String!]!
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

type FreelancerConnection {
  pageInfo: PageInfo!
  edges: [FreelancerEdge]!
  aggregate: AggregateFreelancer!
}

input FreelancerCreateInput {
  id: ID
  user: UserCreateOneWithoutFreelancerInput
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills: SkillCreateManyWithoutFreelancerInput
  education: EducationCreateManyWithoutFreelancerInput
  location: String
  languageSkills: LanguageSkillCreateManyWithoutFreelancerInput
  experiences: ExperienceCreateManyWithoutFreelancerInput
  portfolio: PortfolioCreateManyWithoutFreelancerInput
  certification: CertificationCreateManyWithoutFreelancerInput
  publications: PublicationCreateManyWithoutFreelancerInput
  tags: FreelancerCreatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerCreateManyWithoutSkillsInput {
  create: [FreelancerCreateWithoutSkillsInput!]
  connect: [FreelancerWhereUniqueInput!]
}

input FreelancerCreateOneInput {
  create: FreelancerCreateInput
  connect: FreelancerWhereUniqueInput
}

input FreelancerCreateOneWithoutCertificationInput {
  create: FreelancerCreateWithoutCertificationInput
  connect: FreelancerWhereUniqueInput
}

input FreelancerCreateOneWithoutEducationInput {
  create: FreelancerCreateWithoutEducationInput
  connect: FreelancerWhereUniqueInput
}

input FreelancerCreateOneWithoutExperiencesInput {
  create: FreelancerCreateWithoutExperiencesInput
  connect: FreelancerWhereUniqueInput
}

input FreelancerCreateOneWithoutLanguageSkillsInput {
  create: FreelancerCreateWithoutLanguageSkillsInput
  connect: FreelancerWhereUniqueInput
}

input FreelancerCreateOneWithoutPortfolioInput {
  create: FreelancerCreateWithoutPortfolioInput
  connect: FreelancerWhereUniqueInput
}

input FreelancerCreateOneWithoutPublicationsInput {
  create: FreelancerCreateWithoutPublicationsInput
  connect: FreelancerWhereUniqueInput
}

input FreelancerCreateOneWithoutUserInput {
  create: FreelancerCreateWithoutUserInput
  connect: FreelancerWhereUniqueInput
}

input FreelancerCreatetagsInput {
  set: [String!]
}

input FreelancerCreateWithoutCertificationInput {
  id: ID
  user: UserCreateOneWithoutFreelancerInput
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills: SkillCreateManyWithoutFreelancerInput
  education: EducationCreateManyWithoutFreelancerInput
  location: String
  languageSkills: LanguageSkillCreateManyWithoutFreelancerInput
  experiences: ExperienceCreateManyWithoutFreelancerInput
  portfolio: PortfolioCreateManyWithoutFreelancerInput
  publications: PublicationCreateManyWithoutFreelancerInput
  tags: FreelancerCreatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerCreateWithoutEducationInput {
  id: ID
  user: UserCreateOneWithoutFreelancerInput
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills: SkillCreateManyWithoutFreelancerInput
  location: String
  languageSkills: LanguageSkillCreateManyWithoutFreelancerInput
  experiences: ExperienceCreateManyWithoutFreelancerInput
  portfolio: PortfolioCreateManyWithoutFreelancerInput
  certification: CertificationCreateManyWithoutFreelancerInput
  publications: PublicationCreateManyWithoutFreelancerInput
  tags: FreelancerCreatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerCreateWithoutExperiencesInput {
  id: ID
  user: UserCreateOneWithoutFreelancerInput
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills: SkillCreateManyWithoutFreelancerInput
  education: EducationCreateManyWithoutFreelancerInput
  location: String
  languageSkills: LanguageSkillCreateManyWithoutFreelancerInput
  portfolio: PortfolioCreateManyWithoutFreelancerInput
  certification: CertificationCreateManyWithoutFreelancerInput
  publications: PublicationCreateManyWithoutFreelancerInput
  tags: FreelancerCreatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerCreateWithoutLanguageSkillsInput {
  id: ID
  user: UserCreateOneWithoutFreelancerInput
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills: SkillCreateManyWithoutFreelancerInput
  education: EducationCreateManyWithoutFreelancerInput
  location: String
  experiences: ExperienceCreateManyWithoutFreelancerInput
  portfolio: PortfolioCreateManyWithoutFreelancerInput
  certification: CertificationCreateManyWithoutFreelancerInput
  publications: PublicationCreateManyWithoutFreelancerInput
  tags: FreelancerCreatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerCreateWithoutPortfolioInput {
  id: ID
  user: UserCreateOneWithoutFreelancerInput
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills: SkillCreateManyWithoutFreelancerInput
  education: EducationCreateManyWithoutFreelancerInput
  location: String
  languageSkills: LanguageSkillCreateManyWithoutFreelancerInput
  experiences: ExperienceCreateManyWithoutFreelancerInput
  certification: CertificationCreateManyWithoutFreelancerInput
  publications: PublicationCreateManyWithoutFreelancerInput
  tags: FreelancerCreatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerCreateWithoutPublicationsInput {
  id: ID
  user: UserCreateOneWithoutFreelancerInput
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills: SkillCreateManyWithoutFreelancerInput
  education: EducationCreateManyWithoutFreelancerInput
  location: String
  languageSkills: LanguageSkillCreateManyWithoutFreelancerInput
  experiences: ExperienceCreateManyWithoutFreelancerInput
  portfolio: PortfolioCreateManyWithoutFreelancerInput
  certification: CertificationCreateManyWithoutFreelancerInput
  tags: FreelancerCreatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerCreateWithoutSkillsInput {
  id: ID
  user: UserCreateOneWithoutFreelancerInput
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  education: EducationCreateManyWithoutFreelancerInput
  location: String
  languageSkills: LanguageSkillCreateManyWithoutFreelancerInput
  experiences: ExperienceCreateManyWithoutFreelancerInput
  portfolio: PortfolioCreateManyWithoutFreelancerInput
  certification: CertificationCreateManyWithoutFreelancerInput
  publications: PublicationCreateManyWithoutFreelancerInput
  tags: FreelancerCreatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerCreateWithoutUserInput {
  id: ID
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills: SkillCreateManyWithoutFreelancerInput
  education: EducationCreateManyWithoutFreelancerInput
  location: String
  languageSkills: LanguageSkillCreateManyWithoutFreelancerInput
  experiences: ExperienceCreateManyWithoutFreelancerInput
  portfolio: PortfolioCreateManyWithoutFreelancerInput
  certification: CertificationCreateManyWithoutFreelancerInput
  publications: PublicationCreateManyWithoutFreelancerInput
  tags: FreelancerCreatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

type FreelancerEdge {
  node: Freelancer!
  cursor: String!
}

enum FreelancerOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  status_ASC
  status_DESC
  isDeleted_ASC
  isDeleted_DESC
  jobTitle_ASC
  jobTitle_DESC
  completeProfiles_ASC
  completeProfiles_DESC
  rank_ASC
  rank_DESC
  hoursRate_ASC
  hoursRate_DESC
  aboutFreelancer_ASC
  aboutFreelancer_DESC
  availability_ASC
  availability_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  expYears_ASC
  expYears_DESC
  location_ASC
  location_DESC
  isInvitedToProposal_ASC
  isInvitedToProposal_DESC
  isShortlist_ASC
  isShortlist_DESC
  isArchived_ASC
  isArchived_DESC
}

type FreelancerPreviousValues {
  id: ID!
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  location: String
  tags: [String!]!
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  status: String
  status_not: String
  status_in: [String!]
  status_not_in: [String!]
  status_lt: String
  status_lte: String
  status_gt: String
  status_gte: String
  status_contains: String
  status_not_contains: String
  status_starts_with: String
  status_not_starts_with: String
  status_ends_with: String
  status_not_ends_with: String
  isDeleted: Boolean
  isDeleted_not: Boolean
  jobTitle: String
  jobTitle_not: String
  jobTitle_in: [String!]
  jobTitle_not_in: [String!]
  jobTitle_lt: String
  jobTitle_lte: String
  jobTitle_gt: String
  jobTitle_gte: String
  jobTitle_contains: String
  jobTitle_not_contains: String
  jobTitle_starts_with: String
  jobTitle_not_starts_with: String
  jobTitle_ends_with: String
  jobTitle_not_ends_with: String
  completeProfiles: Int
  completeProfiles_not: Int
  completeProfiles_in: [Int!]
  completeProfiles_not_in: [Int!]
  completeProfiles_lt: Int
  completeProfiles_lte: Int
  completeProfiles_gt: Int
  completeProfiles_gte: Int
  rank: Int
  rank_not: Int
  rank_in: [Int!]
  rank_not_in: [Int!]
  rank_lt: Int
  rank_lte: Int
  rank_gt: Int
  rank_gte: Int
  hoursRate: Int
  hoursRate_not: Int
  hoursRate_in: [Int!]
  hoursRate_not_in: [Int!]
  hoursRate_lt: Int
  hoursRate_lte: Int
  hoursRate_gt: Int
  hoursRate_gte: Int
  aboutFreelancer: String
  aboutFreelancer_not: String
  aboutFreelancer_in: [String!]
  aboutFreelancer_not_in: [String!]
  aboutFreelancer_lt: String
  aboutFreelancer_lte: String
  aboutFreelancer_gt: String
  aboutFreelancer_gte: String
  aboutFreelancer_contains: String
  aboutFreelancer_not_contains: String
  aboutFreelancer_starts_with: String
  aboutFreelancer_not_starts_with: String
  aboutFreelancer_ends_with: String
  aboutFreelancer_not_ends_with: String
  availability: Int
  availability_not: Int
  availability_in: [Int!]
  availability_not_in: [Int!]
  availability_lt: Int
  availability_lte: Int
  availability_gt: Int
  availability_gte: Int
  phoneNumber: Int
  phoneNumber_not: Int
  phoneNumber_in: [Int!]
  phoneNumber_not_in: [Int!]
  phoneNumber_lt: Int
  phoneNumber_lte: Int
  phoneNumber_gt: Int
  phoneNumber_gte: Int
  expYears: Int
  expYears_not: Int
  expYears_in: [Int!]
  expYears_not_in: [Int!]
  expYears_lt: Int
  expYears_lte: Int
  expYears_gt: Int
  expYears_gte: Int
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  isInvitedToProposal: Boolean
  isInvitedToProposal_not: Boolean
  isShortlist: Boolean
  isShortlist_not: Boolean
  isArchived: Boolean
  isArchived_not: Boolean
  AND: [FreelancerScalarWhereInput!]
  OR: [FreelancerScalarWhereInput!]
  NOT: [FreelancerScalarWhereInput!]
}

type FreelancerShortList {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  freelancer: Freelancer
  job: Job
  status: FreelancerShortListStatus
  isProposal: Boolean
}

type FreelancerShortListConnection {
  pageInfo: PageInfo!
  edges: [FreelancerShortListEdge]!
  aggregate: AggregateFreelancerShortList!
}

input FreelancerShortListCreateInput {
  id: ID
  freelancer: FreelancerCreateOneInput
  job: JobCreateOneInput
  status: FreelancerShortListStatus
  isProposal: Boolean
}

type FreelancerShortListEdge {
  node: FreelancerShortList!
  cursor: String!
}

enum FreelancerShortListOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  status_ASC
  status_DESC
  isProposal_ASC
  isProposal_DESC
}

type FreelancerShortListPreviousValues {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  status: FreelancerShortListStatus
  isProposal: Boolean
}

enum FreelancerShortListStatus {
  ACTIVE
  ARCHIVE
}

type FreelancerShortListSubscriptionPayload {
  mutation: MutationType!
  node: FreelancerShortList
  updatedFields: [String!]
  previousValues: FreelancerShortListPreviousValues
}

input FreelancerShortListSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FreelancerShortListWhereInput
  AND: [FreelancerShortListSubscriptionWhereInput!]
  OR: [FreelancerShortListSubscriptionWhereInput!]
  NOT: [FreelancerShortListSubscriptionWhereInput!]
}

input FreelancerShortListUpdateInput {
  freelancer: FreelancerUpdateOneInput
  job: JobUpdateOneInput
  status: FreelancerShortListStatus
  isProposal: Boolean
}

input FreelancerShortListUpdateManyMutationInput {
  status: FreelancerShortListStatus
  isProposal: Boolean
}

input FreelancerShortListWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  freelancer: FreelancerWhereInput
  job: JobWhereInput
  status: FreelancerShortListStatus
  status_not: FreelancerShortListStatus
  status_in: [FreelancerShortListStatus!]
  status_not_in: [FreelancerShortListStatus!]
  isProposal: Boolean
  isProposal_not: Boolean
  AND: [FreelancerShortListWhereInput!]
  OR: [FreelancerShortListWhereInput!]
  NOT: [FreelancerShortListWhereInput!]
}

input FreelancerShortListWhereUniqueInput {
  id: ID
}

type FreelancerSubscriptionPayload {
  mutation: MutationType!
  node: Freelancer
  updatedFields: [String!]
  previousValues: FreelancerPreviousValues
}

input FreelancerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FreelancerWhereInput
  AND: [FreelancerSubscriptionWhereInput!]
  OR: [FreelancerSubscriptionWhereInput!]
  NOT: [FreelancerSubscriptionWhereInput!]
}

input FreelancerUpdateDataInput {
  user: UserUpdateOneWithoutFreelancerInput
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills: SkillUpdateManyWithoutFreelancerInput
  education: EducationUpdateManyWithoutFreelancerInput
  location: String
  languageSkills: LanguageSkillUpdateManyWithoutFreelancerInput
  experiences: ExperienceUpdateManyWithoutFreelancerInput
  portfolio: PortfolioUpdateManyWithoutFreelancerInput
  certification: CertificationUpdateManyWithoutFreelancerInput
  publications: PublicationUpdateManyWithoutFreelancerInput
  tags: FreelancerUpdatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerUpdateInput {
  user: UserUpdateOneWithoutFreelancerInput
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills: SkillUpdateManyWithoutFreelancerInput
  education: EducationUpdateManyWithoutFreelancerInput
  location: String
  languageSkills: LanguageSkillUpdateManyWithoutFreelancerInput
  experiences: ExperienceUpdateManyWithoutFreelancerInput
  portfolio: PortfolioUpdateManyWithoutFreelancerInput
  certification: CertificationUpdateManyWithoutFreelancerInput
  publications: PublicationUpdateManyWithoutFreelancerInput
  tags: FreelancerUpdatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerUpdateManyDataInput {
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  location: String
  tags: FreelancerUpdatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerUpdateManyMutationInput {
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  location: String
  tags: FreelancerUpdatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerUpdateManyWithoutSkillsInput {
  create: [FreelancerCreateWithoutSkillsInput!]
  delete: [FreelancerWhereUniqueInput!]
  connect: [FreelancerWhereUniqueInput!]
  set: [FreelancerWhereUniqueInput!]
  disconnect: [FreelancerWhereUniqueInput!]
  update: [FreelancerUpdateWithWhereUniqueWithoutSkillsInput!]
  upsert: [FreelancerUpsertWithWhereUniqueWithoutSkillsInput!]
  deleteMany: [FreelancerScalarWhereInput!]
  updateMany: [FreelancerUpdateManyWithWhereNestedInput!]
}

input FreelancerUpdateManyWithWhereNestedInput {
  where: FreelancerScalarWhereInput!
  data: FreelancerUpdateManyDataInput!
}

input FreelancerUpdateOneInput {
  create: FreelancerCreateInput
  update: FreelancerUpdateDataInput
  upsert: FreelancerUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: FreelancerWhereUniqueInput
}

input FreelancerUpdateOneRequiredInput {
  create: FreelancerCreateInput
  update: FreelancerUpdateDataInput
  upsert: FreelancerUpsertNestedInput
  connect: FreelancerWhereUniqueInput
}

input FreelancerUpdateOneWithoutCertificationInput {
  create: FreelancerCreateWithoutCertificationInput
  update: FreelancerUpdateWithoutCertificationDataInput
  upsert: FreelancerUpsertWithoutCertificationInput
  delete: Boolean
  disconnect: Boolean
  connect: FreelancerWhereUniqueInput
}

input FreelancerUpdateOneWithoutEducationInput {
  create: FreelancerCreateWithoutEducationInput
  update: FreelancerUpdateWithoutEducationDataInput
  upsert: FreelancerUpsertWithoutEducationInput
  delete: Boolean
  disconnect: Boolean
  connect: FreelancerWhereUniqueInput
}

input FreelancerUpdateOneWithoutExperiencesInput {
  create: FreelancerCreateWithoutExperiencesInput
  update: FreelancerUpdateWithoutExperiencesDataInput
  upsert: FreelancerUpsertWithoutExperiencesInput
  delete: Boolean
  disconnect: Boolean
  connect: FreelancerWhereUniqueInput
}

input FreelancerUpdateOneWithoutLanguageSkillsInput {
  create: FreelancerCreateWithoutLanguageSkillsInput
  update: FreelancerUpdateWithoutLanguageSkillsDataInput
  upsert: FreelancerUpsertWithoutLanguageSkillsInput
  delete: Boolean
  disconnect: Boolean
  connect: FreelancerWhereUniqueInput
}

input FreelancerUpdateOneWithoutPortfolioInput {
  create: FreelancerCreateWithoutPortfolioInput
  update: FreelancerUpdateWithoutPortfolioDataInput
  upsert: FreelancerUpsertWithoutPortfolioInput
  delete: Boolean
  disconnect: Boolean
  connect: FreelancerWhereUniqueInput
}

input FreelancerUpdateOneWithoutPublicationsInput {
  create: FreelancerCreateWithoutPublicationsInput
  update: FreelancerUpdateWithoutPublicationsDataInput
  upsert: FreelancerUpsertWithoutPublicationsInput
  delete: Boolean
  disconnect: Boolean
  connect: FreelancerWhereUniqueInput
}

input FreelancerUpdateOneWithoutUserInput {
  create: FreelancerCreateWithoutUserInput
  update: FreelancerUpdateWithoutUserDataInput
  upsert: FreelancerUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  connect: FreelancerWhereUniqueInput
}

input FreelancerUpdatetagsInput {
  set: [String!]
}

input FreelancerUpdateWithoutCertificationDataInput {
  user: UserUpdateOneWithoutFreelancerInput
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills: SkillUpdateManyWithoutFreelancerInput
  education: EducationUpdateManyWithoutFreelancerInput
  location: String
  languageSkills: LanguageSkillUpdateManyWithoutFreelancerInput
  experiences: ExperienceUpdateManyWithoutFreelancerInput
  portfolio: PortfolioUpdateManyWithoutFreelancerInput
  publications: PublicationUpdateManyWithoutFreelancerInput
  tags: FreelancerUpdatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerUpdateWithoutEducationDataInput {
  user: UserUpdateOneWithoutFreelancerInput
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills: SkillUpdateManyWithoutFreelancerInput
  location: String
  languageSkills: LanguageSkillUpdateManyWithoutFreelancerInput
  experiences: ExperienceUpdateManyWithoutFreelancerInput
  portfolio: PortfolioUpdateManyWithoutFreelancerInput
  certification: CertificationUpdateManyWithoutFreelancerInput
  publications: PublicationUpdateManyWithoutFreelancerInput
  tags: FreelancerUpdatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerUpdateWithoutExperiencesDataInput {
  user: UserUpdateOneWithoutFreelancerInput
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills: SkillUpdateManyWithoutFreelancerInput
  education: EducationUpdateManyWithoutFreelancerInput
  location: String
  languageSkills: LanguageSkillUpdateManyWithoutFreelancerInput
  portfolio: PortfolioUpdateManyWithoutFreelancerInput
  certification: CertificationUpdateManyWithoutFreelancerInput
  publications: PublicationUpdateManyWithoutFreelancerInput
  tags: FreelancerUpdatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerUpdateWithoutLanguageSkillsDataInput {
  user: UserUpdateOneWithoutFreelancerInput
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills: SkillUpdateManyWithoutFreelancerInput
  education: EducationUpdateManyWithoutFreelancerInput
  location: String
  experiences: ExperienceUpdateManyWithoutFreelancerInput
  portfolio: PortfolioUpdateManyWithoutFreelancerInput
  certification: CertificationUpdateManyWithoutFreelancerInput
  publications: PublicationUpdateManyWithoutFreelancerInput
  tags: FreelancerUpdatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerUpdateWithoutPortfolioDataInput {
  user: UserUpdateOneWithoutFreelancerInput
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills: SkillUpdateManyWithoutFreelancerInput
  education: EducationUpdateManyWithoutFreelancerInput
  location: String
  languageSkills: LanguageSkillUpdateManyWithoutFreelancerInput
  experiences: ExperienceUpdateManyWithoutFreelancerInput
  certification: CertificationUpdateManyWithoutFreelancerInput
  publications: PublicationUpdateManyWithoutFreelancerInput
  tags: FreelancerUpdatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerUpdateWithoutPublicationsDataInput {
  user: UserUpdateOneWithoutFreelancerInput
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills: SkillUpdateManyWithoutFreelancerInput
  education: EducationUpdateManyWithoutFreelancerInput
  location: String
  languageSkills: LanguageSkillUpdateManyWithoutFreelancerInput
  experiences: ExperienceUpdateManyWithoutFreelancerInput
  portfolio: PortfolioUpdateManyWithoutFreelancerInput
  certification: CertificationUpdateManyWithoutFreelancerInput
  tags: FreelancerUpdatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerUpdateWithoutSkillsDataInput {
  user: UserUpdateOneWithoutFreelancerInput
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  education: EducationUpdateManyWithoutFreelancerInput
  location: String
  languageSkills: LanguageSkillUpdateManyWithoutFreelancerInput
  experiences: ExperienceUpdateManyWithoutFreelancerInput
  portfolio: PortfolioUpdateManyWithoutFreelancerInput
  certification: CertificationUpdateManyWithoutFreelancerInput
  publications: PublicationUpdateManyWithoutFreelancerInput
  tags: FreelancerUpdatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerUpdateWithoutUserDataInput {
  type: String
  status: String
  isDeleted: Boolean
  jobTitle: String
  completeProfiles: Int
  rank: Int
  hoursRate: Int
  aboutFreelancer: String
  availability: Int
  phoneNumber: Int
  expYears: Int
  skills: SkillUpdateManyWithoutFreelancerInput
  education: EducationUpdateManyWithoutFreelancerInput
  location: String
  languageSkills: LanguageSkillUpdateManyWithoutFreelancerInput
  experiences: ExperienceUpdateManyWithoutFreelancerInput
  portfolio: PortfolioUpdateManyWithoutFreelancerInput
  certification: CertificationUpdateManyWithoutFreelancerInput
  publications: PublicationUpdateManyWithoutFreelancerInput
  tags: FreelancerUpdatetagsInput
  isInvitedToProposal: Boolean
  isShortlist: Boolean
  isArchived: Boolean
}

input FreelancerUpdateWithWhereUniqueWithoutSkillsInput {
  where: FreelancerWhereUniqueInput!
  data: FreelancerUpdateWithoutSkillsDataInput!
}

input FreelancerUpsertNestedInput {
  update: FreelancerUpdateDataInput!
  create: FreelancerCreateInput!
}

input FreelancerUpsertWithoutCertificationInput {
  update: FreelancerUpdateWithoutCertificationDataInput!
  create: FreelancerCreateWithoutCertificationInput!
}

input FreelancerUpsertWithoutEducationInput {
  update: FreelancerUpdateWithoutEducationDataInput!
  create: FreelancerCreateWithoutEducationInput!
}

input FreelancerUpsertWithoutExperiencesInput {
  update: FreelancerUpdateWithoutExperiencesDataInput!
  create: FreelancerCreateWithoutExperiencesInput!
}

input FreelancerUpsertWithoutLanguageSkillsInput {
  update: FreelancerUpdateWithoutLanguageSkillsDataInput!
  create: FreelancerCreateWithoutLanguageSkillsInput!
}

input FreelancerUpsertWithoutPortfolioInput {
  update: FreelancerUpdateWithoutPortfolioDataInput!
  create: FreelancerCreateWithoutPortfolioInput!
}

input FreelancerUpsertWithoutPublicationsInput {
  update: FreelancerUpdateWithoutPublicationsDataInput!
  create: FreelancerCreateWithoutPublicationsInput!
}

input FreelancerUpsertWithoutUserInput {
  update: FreelancerUpdateWithoutUserDataInput!
  create: FreelancerCreateWithoutUserInput!
}

input FreelancerUpsertWithWhereUniqueWithoutSkillsInput {
  where: FreelancerWhereUniqueInput!
  update: FreelancerUpdateWithoutSkillsDataInput!
  create: FreelancerCreateWithoutSkillsInput!
}

input FreelancerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  status: String
  status_not: String
  status_in: [String!]
  status_not_in: [String!]
  status_lt: String
  status_lte: String
  status_gt: String
  status_gte: String
  status_contains: String
  status_not_contains: String
  status_starts_with: String
  status_not_starts_with: String
  status_ends_with: String
  status_not_ends_with: String
  isDeleted: Boolean
  isDeleted_not: Boolean
  jobTitle: String
  jobTitle_not: String
  jobTitle_in: [String!]
  jobTitle_not_in: [String!]
  jobTitle_lt: String
  jobTitle_lte: String
  jobTitle_gt: String
  jobTitle_gte: String
  jobTitle_contains: String
  jobTitle_not_contains: String
  jobTitle_starts_with: String
  jobTitle_not_starts_with: String
  jobTitle_ends_with: String
  jobTitle_not_ends_with: String
  completeProfiles: Int
  completeProfiles_not: Int
  completeProfiles_in: [Int!]
  completeProfiles_not_in: [Int!]
  completeProfiles_lt: Int
  completeProfiles_lte: Int
  completeProfiles_gt: Int
  completeProfiles_gte: Int
  rank: Int
  rank_not: Int
  rank_in: [Int!]
  rank_not_in: [Int!]
  rank_lt: Int
  rank_lte: Int
  rank_gt: Int
  rank_gte: Int
  hoursRate: Int
  hoursRate_not: Int
  hoursRate_in: [Int!]
  hoursRate_not_in: [Int!]
  hoursRate_lt: Int
  hoursRate_lte: Int
  hoursRate_gt: Int
  hoursRate_gte: Int
  aboutFreelancer: String
  aboutFreelancer_not: String
  aboutFreelancer_in: [String!]
  aboutFreelancer_not_in: [String!]
  aboutFreelancer_lt: String
  aboutFreelancer_lte: String
  aboutFreelancer_gt: String
  aboutFreelancer_gte: String
  aboutFreelancer_contains: String
  aboutFreelancer_not_contains: String
  aboutFreelancer_starts_with: String
  aboutFreelancer_not_starts_with: String
  aboutFreelancer_ends_with: String
  aboutFreelancer_not_ends_with: String
  availability: Int
  availability_not: Int
  availability_in: [Int!]
  availability_not_in: [Int!]
  availability_lt: Int
  availability_lte: Int
  availability_gt: Int
  availability_gte: Int
  phoneNumber: Int
  phoneNumber_not: Int
  phoneNumber_in: [Int!]
  phoneNumber_not_in: [Int!]
  phoneNumber_lt: Int
  phoneNumber_lte: Int
  phoneNumber_gt: Int
  phoneNumber_gte: Int
  expYears: Int
  expYears_not: Int
  expYears_in: [Int!]
  expYears_not_in: [Int!]
  expYears_lt: Int
  expYears_lte: Int
  expYears_gt: Int
  expYears_gte: Int
  skills_every: SkillWhereInput
  skills_some: SkillWhereInput
  skills_none: SkillWhereInput
  education_every: EducationWhereInput
  education_some: EducationWhereInput
  education_none: EducationWhereInput
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  languageSkills_every: LanguageSkillWhereInput
  languageSkills_some: LanguageSkillWhereInput
  languageSkills_none: LanguageSkillWhereInput
  experiences_every: ExperienceWhereInput
  experiences_some: ExperienceWhereInput
  experiences_none: ExperienceWhereInput
  portfolio_every: PortfolioWhereInput
  portfolio_some: PortfolioWhereInput
  portfolio_none: PortfolioWhereInput
  certification_every: CertificationWhereInput
  certification_some: CertificationWhereInput
  certification_none: CertificationWhereInput
  publications_every: PublicationWhereInput
  publications_some: PublicationWhereInput
  publications_none: PublicationWhereInput
  isInvitedToProposal: Boolean
  isInvitedToProposal_not: Boolean
  isShortlist: Boolean
  isShortlist_not: Boolean
  isArchived: Boolean
  isArchived_not: Boolean
  AND: [FreelancerWhereInput!]
  OR: [FreelancerWhereInput!]
  NOT: [FreelancerWhereInput!]
}

input FreelancerWhereUniqueInput {
  id: ID
}

type Hire {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  offer: Offer!
  status: HIRE_STATUS!
  job: Job
}

enum HIRE_STATUS {
  HIRING
  PAUSED
  STOPED
}

type HireConnection {
  pageInfo: PageInfo!
  edges: [HireEdge]!
  aggregate: AggregateHire!
}

input HireCreateInput {
  id: ID
  offer: OfferCreateOneInput!
  status: HIRE_STATUS!
  job: JobCreateOneInput
}

type HireEdge {
  node: Hire!
  cursor: String!
}

enum HireOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  status_ASC
  status_DESC
}

type HirePreviousValues {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  status: HIRE_STATUS!
}

type HireSubscriptionPayload {
  mutation: MutationType!
  node: Hire
  updatedFields: [String!]
  previousValues: HirePreviousValues
}

input HireSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HireWhereInput
  AND: [HireSubscriptionWhereInput!]
  OR: [HireSubscriptionWhereInput!]
  NOT: [HireSubscriptionWhereInput!]
}

input HireUpdateInput {
  offer: OfferUpdateOneRequiredInput
  status: HIRE_STATUS
  job: JobUpdateOneInput
}

input HireUpdateManyMutationInput {
  status: HIRE_STATUS
}

input HireWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  offer: OfferWhereInput
  status: HIRE_STATUS
  status_not: HIRE_STATUS
  status_in: [HIRE_STATUS!]
  status_not_in: [HIRE_STATUS!]
  job: JobWhereInput
  AND: [HireWhereInput!]
  OR: [HireWhereInput!]
  NOT: [HireWhereInput!]
}

input HireWhereUniqueInput {
  id: ID
}

type Interview {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  freelancer: Freelancer
  job: Job
  conversation: Conversation
  active: Boolean
}

type InterviewConnection {
  pageInfo: PageInfo!
  edges: [InterviewEdge]!
  aggregate: AggregateInterview!
}

input InterviewCreateInput {
  id: ID
  freelancer: FreelancerCreateOneInput
  job: JobCreateOneInput
  conversation: ConversationCreateOneInput
  active: Boolean
}

type InterviewEdge {
  node: Interview!
  cursor: String!
}

enum InterviewOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  active_ASC
  active_DESC
}

type InterviewPreviousValues {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  active: Boolean
}

type InterviewSubscriptionPayload {
  mutation: MutationType!
  node: Interview
  updatedFields: [String!]
  previousValues: InterviewPreviousValues
}

input InterviewSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InterviewWhereInput
  AND: [InterviewSubscriptionWhereInput!]
  OR: [InterviewSubscriptionWhereInput!]
  NOT: [InterviewSubscriptionWhereInput!]
}

input InterviewUpdateInput {
  freelancer: FreelancerUpdateOneInput
  job: JobUpdateOneInput
  conversation: ConversationUpdateOneInput
  active: Boolean
}

input InterviewUpdateManyMutationInput {
  active: Boolean
}

input InterviewWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  freelancer: FreelancerWhereInput
  job: JobWhereInput
  conversation: ConversationWhereInput
  active: Boolean
  active_not: Boolean
  AND: [InterviewWhereInput!]
  OR: [InterviewWhereInput!]
  NOT: [InterviewWhereInput!]
}

input InterviewWhereUniqueInput {
  id: ID
}

type Job {
  id: ID!
  employer: Employer
  createdAt: DateTime
  updatedAt: DateTime
  title: String
  category: String
  description: String
  attachments(where: AttachmentWhereInput, orderBy: AttachmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attachment!]
  type: String
  budget: Int
  location: String
  visibility: Boolean
  payingType: String
  duration: String
  skills(where: NeedSkillWhereInput, orderBy: NeedSkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NeedSkill!]
  isDeleted: Boolean
  active: Boolean
  tags: [String!]!
  isSendProposal: Boolean
  isWatched: Boolean
}

type JobConnection {
  pageInfo: PageInfo!
  edges: [JobEdge]!
  aggregate: AggregateJob!
}

input JobCreateInput {
  id: ID
  employer: EmployerCreateOneWithoutJobInput
  title: String
  category: String
  description: String
  attachments: AttachmentCreateManyInput
  type: String
  budget: Int
  location: String
  visibility: Boolean
  payingType: String
  duration: String
  skills: NeedSkillCreateManyWithoutJobInput
  isDeleted: Boolean
  active: Boolean
  tags: JobCreatetagsInput
  isSendProposal: Boolean
  isWatched: Boolean
}

input JobCreateManyWithoutEmployerInput {
  create: [JobCreateWithoutEmployerInput!]
  connect: [JobWhereUniqueInput!]
}

input JobCreateOneInput {
  create: JobCreateInput
  connect: JobWhereUniqueInput
}

input JobCreateOneWithoutSkillsInput {
  create: JobCreateWithoutSkillsInput
  connect: JobWhereUniqueInput
}

input JobCreatetagsInput {
  set: [String!]
}

input JobCreateWithoutEmployerInput {
  id: ID
  title: String
  category: String
  description: String
  attachments: AttachmentCreateManyInput
  type: String
  budget: Int
  location: String
  visibility: Boolean
  payingType: String
  duration: String
  skills: NeedSkillCreateManyWithoutJobInput
  isDeleted: Boolean
  active: Boolean
  tags: JobCreatetagsInput
  isSendProposal: Boolean
  isWatched: Boolean
}

input JobCreateWithoutSkillsInput {
  id: ID
  employer: EmployerCreateOneWithoutJobInput
  title: String
  category: String
  description: String
  attachments: AttachmentCreateManyInput
  type: String
  budget: Int
  location: String
  visibility: Boolean
  payingType: String
  duration: String
  isDeleted: Boolean
  active: Boolean
  tags: JobCreatetagsInput
  isSendProposal: Boolean
  isWatched: Boolean
}

type JobEdge {
  node: Job!
  cursor: String!
}

enum JobOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
  category_ASC
  category_DESC
  description_ASC
  description_DESC
  type_ASC
  type_DESC
  budget_ASC
  budget_DESC
  location_ASC
  location_DESC
  visibility_ASC
  visibility_DESC
  payingType_ASC
  payingType_DESC
  duration_ASC
  duration_DESC
  isDeleted_ASC
  isDeleted_DESC
  active_ASC
  active_DESC
  isSendProposal_ASC
  isSendProposal_DESC
  isWatched_ASC
  isWatched_DESC
}

type JobPreviousValues {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  title: String
  category: String
  description: String
  type: String
  budget: Int
  location: String
  visibility: Boolean
  payingType: String
  duration: String
  isDeleted: Boolean
  active: Boolean
  tags: [String!]!
  isSendProposal: Boolean
  isWatched: Boolean
}

input JobScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  category: String
  category_not: String
  category_in: [String!]
  category_not_in: [String!]
  category_lt: String
  category_lte: String
  category_gt: String
  category_gte: String
  category_contains: String
  category_not_contains: String
  category_starts_with: String
  category_not_starts_with: String
  category_ends_with: String
  category_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  budget: Int
  budget_not: Int
  budget_in: [Int!]
  budget_not_in: [Int!]
  budget_lt: Int
  budget_lte: Int
  budget_gt: Int
  budget_gte: Int
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  visibility: Boolean
  visibility_not: Boolean
  payingType: String
  payingType_not: String
  payingType_in: [String!]
  payingType_not_in: [String!]
  payingType_lt: String
  payingType_lte: String
  payingType_gt: String
  payingType_gte: String
  payingType_contains: String
  payingType_not_contains: String
  payingType_starts_with: String
  payingType_not_starts_with: String
  payingType_ends_with: String
  payingType_not_ends_with: String
  duration: String
  duration_not: String
  duration_in: [String!]
  duration_not_in: [String!]
  duration_lt: String
  duration_lte: String
  duration_gt: String
  duration_gte: String
  duration_contains: String
  duration_not_contains: String
  duration_starts_with: String
  duration_not_starts_with: String
  duration_ends_with: String
  duration_not_ends_with: String
  isDeleted: Boolean
  isDeleted_not: Boolean
  active: Boolean
  active_not: Boolean
  isSendProposal: Boolean
  isSendProposal_not: Boolean
  isWatched: Boolean
  isWatched_not: Boolean
  AND: [JobScalarWhereInput!]
  OR: [JobScalarWhereInput!]
  NOT: [JobScalarWhereInput!]
}

type JobSubscriptionPayload {
  mutation: MutationType!
  node: Job
  updatedFields: [String!]
  previousValues: JobPreviousValues
}

input JobSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: JobWhereInput
  AND: [JobSubscriptionWhereInput!]
  OR: [JobSubscriptionWhereInput!]
  NOT: [JobSubscriptionWhereInput!]
}

input JobUpdateDataInput {
  employer: EmployerUpdateOneWithoutJobInput
  title: String
  category: String
  description: String
  attachments: AttachmentUpdateManyInput
  type: String
  budget: Int
  location: String
  visibility: Boolean
  payingType: String
  duration: String
  skills: NeedSkillUpdateManyWithoutJobInput
  isDeleted: Boolean
  active: Boolean
  tags: JobUpdatetagsInput
  isSendProposal: Boolean
  isWatched: Boolean
}

input JobUpdateInput {
  employer: EmployerUpdateOneWithoutJobInput
  title: String
  category: String
  description: String
  attachments: AttachmentUpdateManyInput
  type: String
  budget: Int
  location: String
  visibility: Boolean
  payingType: String
  duration: String
  skills: NeedSkillUpdateManyWithoutJobInput
  isDeleted: Boolean
  active: Boolean
  tags: JobUpdatetagsInput
  isSendProposal: Boolean
  isWatched: Boolean
}

input JobUpdateManyDataInput {
  title: String
  category: String
  description: String
  type: String
  budget: Int
  location: String
  visibility: Boolean
  payingType: String
  duration: String
  isDeleted: Boolean
  active: Boolean
  tags: JobUpdatetagsInput
  isSendProposal: Boolean
  isWatched: Boolean
}

input JobUpdateManyMutationInput {
  title: String
  category: String
  description: String
  type: String
  budget: Int
  location: String
  visibility: Boolean
  payingType: String
  duration: String
  isDeleted: Boolean
  active: Boolean
  tags: JobUpdatetagsInput
  isSendProposal: Boolean
  isWatched: Boolean
}

input JobUpdateManyWithoutEmployerInput {
  create: [JobCreateWithoutEmployerInput!]
  delete: [JobWhereUniqueInput!]
  connect: [JobWhereUniqueInput!]
  set: [JobWhereUniqueInput!]
  disconnect: [JobWhereUniqueInput!]
  update: [JobUpdateWithWhereUniqueWithoutEmployerInput!]
  upsert: [JobUpsertWithWhereUniqueWithoutEmployerInput!]
  deleteMany: [JobScalarWhereInput!]
  updateMany: [JobUpdateManyWithWhereNestedInput!]
}

input JobUpdateManyWithWhereNestedInput {
  where: JobScalarWhereInput!
  data: JobUpdateManyDataInput!
}

input JobUpdateOneInput {
  create: JobCreateInput
  update: JobUpdateDataInput
  upsert: JobUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: JobWhereUniqueInput
}

input JobUpdateOneRequiredInput {
  create: JobCreateInput
  update: JobUpdateDataInput
  upsert: JobUpsertNestedInput
  connect: JobWhereUniqueInput
}

input JobUpdateOneWithoutSkillsInput {
  create: JobCreateWithoutSkillsInput
  update: JobUpdateWithoutSkillsDataInput
  upsert: JobUpsertWithoutSkillsInput
  delete: Boolean
  disconnect: Boolean
  connect: JobWhereUniqueInput
}

input JobUpdatetagsInput {
  set: [String!]
}

input JobUpdateWithoutEmployerDataInput {
  title: String
  category: String
  description: String
  attachments: AttachmentUpdateManyInput
  type: String
  budget: Int
  location: String
  visibility: Boolean
  payingType: String
  duration: String
  skills: NeedSkillUpdateManyWithoutJobInput
  isDeleted: Boolean
  active: Boolean
  tags: JobUpdatetagsInput
  isSendProposal: Boolean
  isWatched: Boolean
}

input JobUpdateWithoutSkillsDataInput {
  employer: EmployerUpdateOneWithoutJobInput
  title: String
  category: String
  description: String
  attachments: AttachmentUpdateManyInput
  type: String
  budget: Int
  location: String
  visibility: Boolean
  payingType: String
  duration: String
  isDeleted: Boolean
  active: Boolean
  tags: JobUpdatetagsInput
  isSendProposal: Boolean
  isWatched: Boolean
}

input JobUpdateWithWhereUniqueWithoutEmployerInput {
  where: JobWhereUniqueInput!
  data: JobUpdateWithoutEmployerDataInput!
}

input JobUpsertNestedInput {
  update: JobUpdateDataInput!
  create: JobCreateInput!
}

input JobUpsertWithoutSkillsInput {
  update: JobUpdateWithoutSkillsDataInput!
  create: JobCreateWithoutSkillsInput!
}

input JobUpsertWithWhereUniqueWithoutEmployerInput {
  where: JobWhereUniqueInput!
  update: JobUpdateWithoutEmployerDataInput!
  create: JobCreateWithoutEmployerInput!
}

input JobWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  employer: EmployerWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  category: String
  category_not: String
  category_in: [String!]
  category_not_in: [String!]
  category_lt: String
  category_lte: String
  category_gt: String
  category_gte: String
  category_contains: String
  category_not_contains: String
  category_starts_with: String
  category_not_starts_with: String
  category_ends_with: String
  category_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  attachments_every: AttachmentWhereInput
  attachments_some: AttachmentWhereInput
  attachments_none: AttachmentWhereInput
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  budget: Int
  budget_not: Int
  budget_in: [Int!]
  budget_not_in: [Int!]
  budget_lt: Int
  budget_lte: Int
  budget_gt: Int
  budget_gte: Int
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  visibility: Boolean
  visibility_not: Boolean
  payingType: String
  payingType_not: String
  payingType_in: [String!]
  payingType_not_in: [String!]
  payingType_lt: String
  payingType_lte: String
  payingType_gt: String
  payingType_gte: String
  payingType_contains: String
  payingType_not_contains: String
  payingType_starts_with: String
  payingType_not_starts_with: String
  payingType_ends_with: String
  payingType_not_ends_with: String
  duration: String
  duration_not: String
  duration_in: [String!]
  duration_not_in: [String!]
  duration_lt: String
  duration_lte: String
  duration_gt: String
  duration_gte: String
  duration_contains: String
  duration_not_contains: String
  duration_starts_with: String
  duration_not_starts_with: String
  duration_ends_with: String
  duration_not_ends_with: String
  skills_every: NeedSkillWhereInput
  skills_some: NeedSkillWhereInput
  skills_none: NeedSkillWhereInput
  isDeleted: Boolean
  isDeleted_not: Boolean
  active: Boolean
  active_not: Boolean
  isSendProposal: Boolean
  isSendProposal_not: Boolean
  isWatched: Boolean
  isWatched_not: Boolean
  AND: [JobWhereInput!]
  OR: [JobWhereInput!]
  NOT: [JobWhereInput!]
}

input JobWhereUniqueInput {
  id: ID
}

type LanguageSkill {
  id: ID!
  freelancer: Freelancer
  language: String
  level: String
}

type LanguageSkillConnection {
  pageInfo: PageInfo!
  edges: [LanguageSkillEdge]!
  aggregate: AggregateLanguageSkill!
}

input LanguageSkillCreateInput {
  id: ID
  freelancer: FreelancerCreateOneWithoutLanguageSkillsInput
  language: String
  level: String
}

input LanguageSkillCreateManyWithoutFreelancerInput {
  create: [LanguageSkillCreateWithoutFreelancerInput!]
  connect: [LanguageSkillWhereUniqueInput!]
}

input LanguageSkillCreateWithoutFreelancerInput {
  id: ID
  language: String
  level: String
}

type LanguageSkillEdge {
  node: LanguageSkill!
  cursor: String!
}

enum LanguageSkillOrderByInput {
  id_ASC
  id_DESC
  language_ASC
  language_DESC
  level_ASC
  level_DESC
}

type LanguageSkillPreviousValues {
  id: ID!
  language: String
  level: String
}

input LanguageSkillScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  language: String
  language_not: String
  language_in: [String!]
  language_not_in: [String!]
  language_lt: String
  language_lte: String
  language_gt: String
  language_gte: String
  language_contains: String
  language_not_contains: String
  language_starts_with: String
  language_not_starts_with: String
  language_ends_with: String
  language_not_ends_with: String
  level: String
  level_not: String
  level_in: [String!]
  level_not_in: [String!]
  level_lt: String
  level_lte: String
  level_gt: String
  level_gte: String
  level_contains: String
  level_not_contains: String
  level_starts_with: String
  level_not_starts_with: String
  level_ends_with: String
  level_not_ends_with: String
  AND: [LanguageSkillScalarWhereInput!]
  OR: [LanguageSkillScalarWhereInput!]
  NOT: [LanguageSkillScalarWhereInput!]
}

type LanguageSkillSubscriptionPayload {
  mutation: MutationType!
  node: LanguageSkill
  updatedFields: [String!]
  previousValues: LanguageSkillPreviousValues
}

input LanguageSkillSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LanguageSkillWhereInput
  AND: [LanguageSkillSubscriptionWhereInput!]
  OR: [LanguageSkillSubscriptionWhereInput!]
  NOT: [LanguageSkillSubscriptionWhereInput!]
}

input LanguageSkillUpdateInput {
  freelancer: FreelancerUpdateOneWithoutLanguageSkillsInput
  language: String
  level: String
}

input LanguageSkillUpdateManyDataInput {
  language: String
  level: String
}

input LanguageSkillUpdateManyMutationInput {
  language: String
  level: String
}

input LanguageSkillUpdateManyWithoutFreelancerInput {
  create: [LanguageSkillCreateWithoutFreelancerInput!]
  delete: [LanguageSkillWhereUniqueInput!]
  connect: [LanguageSkillWhereUniqueInput!]
  set: [LanguageSkillWhereUniqueInput!]
  disconnect: [LanguageSkillWhereUniqueInput!]
  update: [LanguageSkillUpdateWithWhereUniqueWithoutFreelancerInput!]
  upsert: [LanguageSkillUpsertWithWhereUniqueWithoutFreelancerInput!]
  deleteMany: [LanguageSkillScalarWhereInput!]
  updateMany: [LanguageSkillUpdateManyWithWhereNestedInput!]
}

input LanguageSkillUpdateManyWithWhereNestedInput {
  where: LanguageSkillScalarWhereInput!
  data: LanguageSkillUpdateManyDataInput!
}

input LanguageSkillUpdateWithoutFreelancerDataInput {
  language: String
  level: String
}

input LanguageSkillUpdateWithWhereUniqueWithoutFreelancerInput {
  where: LanguageSkillWhereUniqueInput!
  data: LanguageSkillUpdateWithoutFreelancerDataInput!
}

input LanguageSkillUpsertWithWhereUniqueWithoutFreelancerInput {
  where: LanguageSkillWhereUniqueInput!
  update: LanguageSkillUpdateWithoutFreelancerDataInput!
  create: LanguageSkillCreateWithoutFreelancerInput!
}

input LanguageSkillWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  freelancer: FreelancerWhereInput
  language: String
  language_not: String
  language_in: [String!]
  language_not_in: [String!]
  language_lt: String
  language_lte: String
  language_gt: String
  language_gte: String
  language_contains: String
  language_not_contains: String
  language_starts_with: String
  language_not_starts_with: String
  language_ends_with: String
  language_not_ends_with: String
  level: String
  level_not: String
  level_in: [String!]
  level_not_in: [String!]
  level_lt: String
  level_lte: String
  level_gt: String
  level_gte: String
  level_contains: String
  level_not_contains: String
  level_starts_with: String
  level_not_starts_with: String
  level_ends_with: String
  level_not_ends_with: String
  AND: [LanguageSkillWhereInput!]
  OR: [LanguageSkillWhereInput!]
  NOT: [LanguageSkillWhereInput!]
}

input LanguageSkillWhereUniqueInput {
  id: ID
}

type ListOfProject {
  id: ID!
  project: Project!
  createdAt: DateTime
  updatedAt: DateTime
  title: String!
  task(where: TaskWhereInput, orderBy: TaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Task!]
}

type ListOfProjectConnection {
  pageInfo: PageInfo!
  edges: [ListOfProjectEdge]!
  aggregate: AggregateListOfProject!
}

input ListOfProjectCreateInput {
  id: ID
  project: ProjectCreateOneWithoutListInput!
  title: String!
  task: TaskCreateManyInput
}

input ListOfProjectCreateManyWithoutProjectInput {
  create: [ListOfProjectCreateWithoutProjectInput!]
  connect: [ListOfProjectWhereUniqueInput!]
}

input ListOfProjectCreateWithoutProjectInput {
  id: ID
  title: String!
  task: TaskCreateManyInput
}

type ListOfProjectEdge {
  node: ListOfProject!
  cursor: String!
}

enum ListOfProjectOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
}

type ListOfProjectPreviousValues {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  title: String!
}

input ListOfProjectScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [ListOfProjectScalarWhereInput!]
  OR: [ListOfProjectScalarWhereInput!]
  NOT: [ListOfProjectScalarWhereInput!]
}

type ListOfProjectSubscriptionPayload {
  mutation: MutationType!
  node: ListOfProject
  updatedFields: [String!]
  previousValues: ListOfProjectPreviousValues
}

input ListOfProjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ListOfProjectWhereInput
  AND: [ListOfProjectSubscriptionWhereInput!]
  OR: [ListOfProjectSubscriptionWhereInput!]
  NOT: [ListOfProjectSubscriptionWhereInput!]
}

input ListOfProjectUpdateInput {
  project: ProjectUpdateOneRequiredWithoutListInput
  title: String
  task: TaskUpdateManyInput
}

input ListOfProjectUpdateManyDataInput {
  title: String
}

input ListOfProjectUpdateManyMutationInput {
  title: String
}

input ListOfProjectUpdateManyWithoutProjectInput {
  create: [ListOfProjectCreateWithoutProjectInput!]
  delete: [ListOfProjectWhereUniqueInput!]
  connect: [ListOfProjectWhereUniqueInput!]
  set: [ListOfProjectWhereUniqueInput!]
  disconnect: [ListOfProjectWhereUniqueInput!]
  update: [ListOfProjectUpdateWithWhereUniqueWithoutProjectInput!]
  upsert: [ListOfProjectUpsertWithWhereUniqueWithoutProjectInput!]
  deleteMany: [ListOfProjectScalarWhereInput!]
  updateMany: [ListOfProjectUpdateManyWithWhereNestedInput!]
}

input ListOfProjectUpdateManyWithWhereNestedInput {
  where: ListOfProjectScalarWhereInput!
  data: ListOfProjectUpdateManyDataInput!
}

input ListOfProjectUpdateWithoutProjectDataInput {
  title: String
  task: TaskUpdateManyInput
}

input ListOfProjectUpdateWithWhereUniqueWithoutProjectInput {
  where: ListOfProjectWhereUniqueInput!
  data: ListOfProjectUpdateWithoutProjectDataInput!
}

input ListOfProjectUpsertWithWhereUniqueWithoutProjectInput {
  where: ListOfProjectWhereUniqueInput!
  update: ListOfProjectUpdateWithoutProjectDataInput!
  create: ListOfProjectCreateWithoutProjectInput!
}

input ListOfProjectWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  project: ProjectWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  task_every: TaskWhereInput
  task_some: TaskWhereInput
  task_none: TaskWhereInput
  AND: [ListOfProjectWhereInput!]
  OR: [ListOfProjectWhereInput!]
  NOT: [ListOfProjectWhereInput!]
}

input ListOfProjectWhereUniqueInput {
  id: ID
}

scalar Long

enum MessageType {
  TEXT
  FILE
}

type Mutation {
  createAssign(data: AssignCreateInput!): Assign!
  updateAssign(data: AssignUpdateInput!, where: AssignWhereUniqueInput!): Assign
  updateManyAssigns(data: AssignUpdateManyMutationInput!, where: AssignWhereInput): BatchPayload!
  upsertAssign(where: AssignWhereUniqueInput!, create: AssignCreateInput!, update: AssignUpdateInput!): Assign!
  deleteAssign(where: AssignWhereUniqueInput!): Assign
  deleteManyAssigns(where: AssignWhereInput): BatchPayload!
  createAttachment(data: AttachmentCreateInput!): Attachment!
  updateAttachment(data: AttachmentUpdateInput!, where: AttachmentWhereUniqueInput!): Attachment
  updateManyAttachments(data: AttachmentUpdateManyMutationInput!, where: AttachmentWhereInput): BatchPayload!
  upsertAttachment(where: AttachmentWhereUniqueInput!, create: AttachmentCreateInput!, update: AttachmentUpdateInput!): Attachment!
  deleteAttachment(where: AttachmentWhereUniqueInput!): Attachment
  deleteManyAttachments(where: AttachmentWhereInput): BatchPayload!
  createCategory(data: CategoryCreateInput!): Category!
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateManyCategories(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  createCertification(data: CertificationCreateInput!): Certification!
  updateCertification(data: CertificationUpdateInput!, where: CertificationWhereUniqueInput!): Certification
  updateManyCertifications(data: CertificationUpdateManyMutationInput!, where: CertificationWhereInput): BatchPayload!
  upsertCertification(where: CertificationWhereUniqueInput!, create: CertificationCreateInput!, update: CertificationUpdateInput!): Certification!
  deleteCertification(where: CertificationWhereUniqueInput!): Certification
  deleteManyCertifications(where: CertificationWhereInput): BatchPayload!
  createCompany(data: CompanyCreateInput!): Company!
  updateCompany(data: CompanyUpdateInput!, where: CompanyWhereUniqueInput!): Company
  updateManyCompanies(data: CompanyUpdateManyMutationInput!, where: CompanyWhereInput): BatchPayload!
  upsertCompany(where: CompanyWhereUniqueInput!, create: CompanyCreateInput!, update: CompanyUpdateInput!): Company!
  deleteCompany(where: CompanyWhereUniqueInput!): Company
  deleteManyCompanies(where: CompanyWhereInput): BatchPayload!
  createContact(data: ContactCreateInput!): Contact!
  updateContact(data: ContactUpdateInput!, where: ContactWhereUniqueInput!): Contact
  updateManyContacts(data: ContactUpdateManyMutationInput!, where: ContactWhereInput): BatchPayload!
  upsertContact(where: ContactWhereUniqueInput!, create: ContactCreateInput!, update: ContactUpdateInput!): Contact!
  deleteContact(where: ContactWhereUniqueInput!): Contact
  deleteManyContacts(where: ContactWhereInput): BatchPayload!
  createConversation(data: ConversationCreateInput!): Conversation!
  updateConversation(data: ConversationUpdateInput!, where: ConversationWhereUniqueInput!): Conversation
  updateManyConversations(data: ConversationUpdateManyMutationInput!, where: ConversationWhereInput): BatchPayload!
  upsertConversation(where: ConversationWhereUniqueInput!, create: ConversationCreateInput!, update: ConversationUpdateInput!): Conversation!
  deleteConversation(where: ConversationWhereUniqueInput!): Conversation
  deleteManyConversations(where: ConversationWhereInput): BatchPayload!
  createEducation(data: EducationCreateInput!): Education!
  updateEducation(data: EducationUpdateInput!, where: EducationWhereUniqueInput!): Education
  updateManyEducations(data: EducationUpdateManyMutationInput!, where: EducationWhereInput): BatchPayload!
  upsertEducation(where: EducationWhereUniqueInput!, create: EducationCreateInput!, update: EducationUpdateInput!): Education!
  deleteEducation(where: EducationWhereUniqueInput!): Education
  deleteManyEducations(where: EducationWhereInput): BatchPayload!
  createEmployer(data: EmployerCreateInput!): Employer!
  updateEmployer(data: EmployerUpdateInput!, where: EmployerWhereUniqueInput!): Employer
  updateManyEmployers(data: EmployerUpdateManyMutationInput!, where: EmployerWhereInput): BatchPayload!
  upsertEmployer(where: EmployerWhereUniqueInput!, create: EmployerCreateInput!, update: EmployerUpdateInput!): Employer!
  deleteEmployer(where: EmployerWhereUniqueInput!): Employer
  deleteManyEmployers(where: EmployerWhereInput): BatchPayload!
  createEmployerShortList(data: EmployerShortListCreateInput!): EmployerShortList!
  updateEmployerShortList(data: EmployerShortListUpdateInput!, where: EmployerShortListWhereUniqueInput!): EmployerShortList
  updateManyEmployerShortLists(data: EmployerShortListUpdateManyMutationInput!, where: EmployerShortListWhereInput): BatchPayload!
  upsertEmployerShortList(where: EmployerShortListWhereUniqueInput!, create: EmployerShortListCreateInput!, update: EmployerShortListUpdateInput!): EmployerShortList!
  deleteEmployerShortList(where: EmployerShortListWhereUniqueInput!): EmployerShortList
  deleteManyEmployerShortLists(where: EmployerShortListWhereInput): BatchPayload!
  createExperience(data: ExperienceCreateInput!): Experience!
  updateExperience(data: ExperienceUpdateInput!, where: ExperienceWhereUniqueInput!): Experience
  updateManyExperiences(data: ExperienceUpdateManyMutationInput!, where: ExperienceWhereInput): BatchPayload!
  upsertExperience(where: ExperienceWhereUniqueInput!, create: ExperienceCreateInput!, update: ExperienceUpdateInput!): Experience!
  deleteExperience(where: ExperienceWhereUniqueInput!): Experience
  deleteManyExperiences(where: ExperienceWhereInput): BatchPayload!
  createFreelancer(data: FreelancerCreateInput!): Freelancer!
  updateFreelancer(data: FreelancerUpdateInput!, where: FreelancerWhereUniqueInput!): Freelancer
  updateManyFreelancers(data: FreelancerUpdateManyMutationInput!, where: FreelancerWhereInput): BatchPayload!
  upsertFreelancer(where: FreelancerWhereUniqueInput!, create: FreelancerCreateInput!, update: FreelancerUpdateInput!): Freelancer!
  deleteFreelancer(where: FreelancerWhereUniqueInput!): Freelancer
  deleteManyFreelancers(where: FreelancerWhereInput): BatchPayload!
  createFreelancerShortList(data: FreelancerShortListCreateInput!): FreelancerShortList!
  updateFreelancerShortList(data: FreelancerShortListUpdateInput!, where: FreelancerShortListWhereUniqueInput!): FreelancerShortList
  updateManyFreelancerShortLists(data: FreelancerShortListUpdateManyMutationInput!, where: FreelancerShortListWhereInput): BatchPayload!
  upsertFreelancerShortList(where: FreelancerShortListWhereUniqueInput!, create: FreelancerShortListCreateInput!, update: FreelancerShortListUpdateInput!): FreelancerShortList!
  deleteFreelancerShortList(where: FreelancerShortListWhereUniqueInput!): FreelancerShortList
  deleteManyFreelancerShortLists(where: FreelancerShortListWhereInput): BatchPayload!
  createHire(data: HireCreateInput!): Hire!
  updateHire(data: HireUpdateInput!, where: HireWhereUniqueInput!): Hire
  updateManyHires(data: HireUpdateManyMutationInput!, where: HireWhereInput): BatchPayload!
  upsertHire(where: HireWhereUniqueInput!, create: HireCreateInput!, update: HireUpdateInput!): Hire!
  deleteHire(where: HireWhereUniqueInput!): Hire
  deleteManyHires(where: HireWhereInput): BatchPayload!
  createInterview(data: InterviewCreateInput!): Interview!
  updateInterview(data: InterviewUpdateInput!, where: InterviewWhereUniqueInput!): Interview
  updateManyInterviews(data: InterviewUpdateManyMutationInput!, where: InterviewWhereInput): BatchPayload!
  upsertInterview(where: InterviewWhereUniqueInput!, create: InterviewCreateInput!, update: InterviewUpdateInput!): Interview!
  deleteInterview(where: InterviewWhereUniqueInput!): Interview
  deleteManyInterviews(where: InterviewWhereInput): BatchPayload!
  createJob(data: JobCreateInput!): Job!
  updateJob(data: JobUpdateInput!, where: JobWhereUniqueInput!): Job
  updateManyJobs(data: JobUpdateManyMutationInput!, where: JobWhereInput): BatchPayload!
  upsertJob(where: JobWhereUniqueInput!, create: JobCreateInput!, update: JobUpdateInput!): Job!
  deleteJob(where: JobWhereUniqueInput!): Job
  deleteManyJobs(where: JobWhereInput): BatchPayload!
  createLanguageSkill(data: LanguageSkillCreateInput!): LanguageSkill!
  updateLanguageSkill(data: LanguageSkillUpdateInput!, where: LanguageSkillWhereUniqueInput!): LanguageSkill
  updateManyLanguageSkills(data: LanguageSkillUpdateManyMutationInput!, where: LanguageSkillWhereInput): BatchPayload!
  upsertLanguageSkill(where: LanguageSkillWhereUniqueInput!, create: LanguageSkillCreateInput!, update: LanguageSkillUpdateInput!): LanguageSkill!
  deleteLanguageSkill(where: LanguageSkillWhereUniqueInput!): LanguageSkill
  deleteManyLanguageSkills(where: LanguageSkillWhereInput): BatchPayload!
  createListOfProject(data: ListOfProjectCreateInput!): ListOfProject!
  updateListOfProject(data: ListOfProjectUpdateInput!, where: ListOfProjectWhereUniqueInput!): ListOfProject
  updateManyListOfProjects(data: ListOfProjectUpdateManyMutationInput!, where: ListOfProjectWhereInput): BatchPayload!
  upsertListOfProject(where: ListOfProjectWhereUniqueInput!, create: ListOfProjectCreateInput!, update: ListOfProjectUpdateInput!): ListOfProject!
  deleteListOfProject(where: ListOfProjectWhereUniqueInput!): ListOfProject
  deleteManyListOfProjects(where: ListOfProjectWhereInput): BatchPayload!
  createNeedSkill(data: NeedSkillCreateInput!): NeedSkill!
  updateNeedSkill(data: NeedSkillUpdateInput!, where: NeedSkillWhereUniqueInput!): NeedSkill
  updateManyNeedSkills(data: NeedSkillUpdateManyMutationInput!, where: NeedSkillWhereInput): BatchPayload!
  upsertNeedSkill(where: NeedSkillWhereUniqueInput!, create: NeedSkillCreateInput!, update: NeedSkillUpdateInput!): NeedSkill!
  deleteNeedSkill(where: NeedSkillWhereUniqueInput!): NeedSkill
  deleteManyNeedSkills(where: NeedSkillWhereInput): BatchPayload!
  createNotification(data: NotificationCreateInput!): Notification!
  updateNotification(data: NotificationUpdateInput!, where: NotificationWhereUniqueInput!): Notification
  updateManyNotifications(data: NotificationUpdateManyMutationInput!, where: NotificationWhereInput): BatchPayload!
  upsertNotification(where: NotificationWhereUniqueInput!, create: NotificationCreateInput!, update: NotificationUpdateInput!): Notification!
  deleteNotification(where: NotificationWhereUniqueInput!): Notification
  deleteManyNotifications(where: NotificationWhereInput): BatchPayload!
  createNotificationBody(data: NotificationBodyCreateInput!): NotificationBody!
  updateNotificationBody(data: NotificationBodyUpdateInput!, where: NotificationBodyWhereUniqueInput!): NotificationBody
  updateManyNotificationBodies(data: NotificationBodyUpdateManyMutationInput!, where: NotificationBodyWhereInput): BatchPayload!
  upsertNotificationBody(where: NotificationBodyWhereUniqueInput!, create: NotificationBodyCreateInput!, update: NotificationBodyUpdateInput!): NotificationBody!
  deleteNotificationBody(where: NotificationBodyWhereUniqueInput!): NotificationBody
  deleteManyNotificationBodies(where: NotificationBodyWhereInput): BatchPayload!
  createOffer(data: OfferCreateInput!): Offer!
  updateOffer(data: OfferUpdateInput!, where: OfferWhereUniqueInput!): Offer
  updateManyOffers(data: OfferUpdateManyMutationInput!, where: OfferWhereInput): BatchPayload!
  upsertOffer(where: OfferWhereUniqueInput!, create: OfferCreateInput!, update: OfferUpdateInput!): Offer!
  deleteOffer(where: OfferWhereUniqueInput!): Offer
  deleteManyOffers(where: OfferWhereInput): BatchPayload!
  createPaymentForTask(data: PaymentForTaskCreateInput!): PaymentForTask!
  updatePaymentForTask(data: PaymentForTaskUpdateInput!, where: PaymentForTaskWhereUniqueInput!): PaymentForTask
  updateManyPaymentForTasks(data: PaymentForTaskUpdateManyMutationInput!, where: PaymentForTaskWhereInput): BatchPayload!
  upsertPaymentForTask(where: PaymentForTaskWhereUniqueInput!, create: PaymentForTaskCreateInput!, update: PaymentForTaskUpdateInput!): PaymentForTask!
  deletePaymentForTask(where: PaymentForTaskWhereUniqueInput!): PaymentForTask
  deleteManyPaymentForTasks(where: PaymentForTaskWhereInput): BatchPayload!
  createPortfolio(data: PortfolioCreateInput!): Portfolio!
  updatePortfolio(data: PortfolioUpdateInput!, where: PortfolioWhereUniqueInput!): Portfolio
  updateManyPortfolios(data: PortfolioUpdateManyMutationInput!, where: PortfolioWhereInput): BatchPayload!
  upsertPortfolio(where: PortfolioWhereUniqueInput!, create: PortfolioCreateInput!, update: PortfolioUpdateInput!): Portfolio!
  deletePortfolio(where: PortfolioWhereUniqueInput!): Portfolio
  deleteManyPortfolios(where: PortfolioWhereInput): BatchPayload!
  createProject(data: ProjectCreateInput!): Project!
  updateProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateManyProjects(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): BatchPayload!
  upsertProject(where: ProjectWhereUniqueInput!, create: ProjectCreateInput!, update: ProjectUpdateInput!): Project!
  deleteProject(where: ProjectWhereUniqueInput!): Project
  deleteManyProjects(where: ProjectWhereInput): BatchPayload!
  createProposal(data: ProposalCreateInput!): Proposal!
  updateProposal(data: ProposalUpdateInput!, where: ProposalWhereUniqueInput!): Proposal
  updateManyProposals(data: ProposalUpdateManyMutationInput!, where: ProposalWhereInput): BatchPayload!
  upsertProposal(where: ProposalWhereUniqueInput!, create: ProposalCreateInput!, update: ProposalUpdateInput!): Proposal!
  deleteProposal(where: ProposalWhereUniqueInput!): Proposal
  deleteManyProposals(where: ProposalWhereInput): BatchPayload!
  createPublication(data: PublicationCreateInput!): Publication!
  updatePublication(data: PublicationUpdateInput!, where: PublicationWhereUniqueInput!): Publication
  updateManyPublications(data: PublicationUpdateManyMutationInput!, where: PublicationWhereInput): BatchPayload!
  upsertPublication(where: PublicationWhereUniqueInput!, create: PublicationCreateInput!, update: PublicationUpdateInput!): Publication!
  deletePublication(where: PublicationWhereUniqueInput!): Publication
  deleteManyPublications(where: PublicationWhereInput): BatchPayload!
  createSkill(data: SkillCreateInput!): Skill!
  updateSkill(data: SkillUpdateInput!, where: SkillWhereUniqueInput!): Skill
  updateManySkills(data: SkillUpdateManyMutationInput!, where: SkillWhereInput): BatchPayload!
  upsertSkill(where: SkillWhereUniqueInput!, create: SkillCreateInput!, update: SkillUpdateInput!): Skill!
  deleteSkill(where: SkillWhereUniqueInput!): Skill
  deleteManySkills(where: SkillWhereInput): BatchPayload!
  createTask(data: TaskCreateInput!): Task!
  updateTask(data: TaskUpdateInput!, where: TaskWhereUniqueInput!): Task
  updateManyTasks(data: TaskUpdateManyMutationInput!, where: TaskWhereInput): BatchPayload!
  upsertTask(where: TaskWhereUniqueInput!, create: TaskCreateInput!, update: TaskUpdateInput!): Task!
  deleteTask(where: TaskWhereUniqueInput!): Task
  deleteManyTasks(where: TaskWhereInput): BatchPayload!
  createTest(data: TestCreateInput!): Test!
  updateTest(data: TestUpdateInput!, where: TestWhereUniqueInput!): Test
  updateManyTests(data: TestUpdateManyMutationInput!, where: TestWhereInput): BatchPayload!
  upsertTest(where: TestWhereUniqueInput!, create: TestCreateInput!, update: TestUpdateInput!): Test!
  deleteTest(where: TestWhereUniqueInput!): Test
  deleteManyTests(where: TestWhereInput): BatchPayload!
  createText(data: TextCreateInput!): Text!
  updateText(data: TextUpdateInput!, where: TextWhereUniqueInput!): Text
  updateManyTexts(data: TextUpdateManyMutationInput!, where: TextWhereInput): BatchPayload!
  upsertText(where: TextWhereUniqueInput!, create: TextCreateInput!, update: TextUpdateInput!): Text!
  deleteText(where: TextWhereUniqueInput!): Text
  deleteManyTexts(where: TextWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createemployerInvitedFreelancer(data: employerInvitedFreelancerCreateInput!): employerInvitedFreelancer!
  updateemployerInvitedFreelancer(data: employerInvitedFreelancerUpdateInput!, where: employerInvitedFreelancerWhereUniqueInput!): employerInvitedFreelancer
  updateManyemployerInvitedFreelancers(data: employerInvitedFreelancerUpdateManyMutationInput!, where: employerInvitedFreelancerWhereInput): BatchPayload!
  upsertemployerInvitedFreelancer(where: employerInvitedFreelancerWhereUniqueInput!, create: employerInvitedFreelancerCreateInput!, update: employerInvitedFreelancerUpdateInput!): employerInvitedFreelancer!
  deleteemployerInvitedFreelancer(where: employerInvitedFreelancerWhereUniqueInput!): employerInvitedFreelancer
  deleteManyemployerInvitedFreelancers(where: employerInvitedFreelancerWhereInput): BatchPayload!
  createpaymentTypeOffer(data: paymentTypeOfferCreateInput!): paymentTypeOffer!
  updatepaymentTypeOffer(data: paymentTypeOfferUpdateInput!, where: paymentTypeOfferWhereUniqueInput!): paymentTypeOffer
  updateManypaymentTypeOffers(data: paymentTypeOfferUpdateManyMutationInput!, where: paymentTypeOfferWhereInput): BatchPayload!
  upsertpaymentTypeOffer(where: paymentTypeOfferWhereUniqueInput!, create: paymentTypeOfferCreateInput!, update: paymentTypeOfferUpdateInput!): paymentTypeOffer!
  deletepaymentTypeOffer(where: paymentTypeOfferWhereUniqueInput!): paymentTypeOffer
  deleteManypaymentTypeOffers(where: paymentTypeOfferWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type NeedSkill {
  id: ID!
  job: Job
  name: String
}

type NeedSkillConnection {
  pageInfo: PageInfo!
  edges: [NeedSkillEdge]!
  aggregate: AggregateNeedSkill!
}

input NeedSkillCreateInput {
  id: ID
  job: JobCreateOneWithoutSkillsInput
  name: String
}

input NeedSkillCreateManyWithoutJobInput {
  create: [NeedSkillCreateWithoutJobInput!]
  connect: [NeedSkillWhereUniqueInput!]
}

input NeedSkillCreateWithoutJobInput {
  id: ID
  name: String
}

type NeedSkillEdge {
  node: NeedSkill!
  cursor: String!
}

enum NeedSkillOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type NeedSkillPreviousValues {
  id: ID!
  name: String
}

input NeedSkillScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [NeedSkillScalarWhereInput!]
  OR: [NeedSkillScalarWhereInput!]
  NOT: [NeedSkillScalarWhereInput!]
}

type NeedSkillSubscriptionPayload {
  mutation: MutationType!
  node: NeedSkill
  updatedFields: [String!]
  previousValues: NeedSkillPreviousValues
}

input NeedSkillSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NeedSkillWhereInput
  AND: [NeedSkillSubscriptionWhereInput!]
  OR: [NeedSkillSubscriptionWhereInput!]
  NOT: [NeedSkillSubscriptionWhereInput!]
}

input NeedSkillUpdateInput {
  job: JobUpdateOneWithoutSkillsInput
  name: String
}

input NeedSkillUpdateManyDataInput {
  name: String
}

input NeedSkillUpdateManyMutationInput {
  name: String
}

input NeedSkillUpdateManyWithoutJobInput {
  create: [NeedSkillCreateWithoutJobInput!]
  delete: [NeedSkillWhereUniqueInput!]
  connect: [NeedSkillWhereUniqueInput!]
  set: [NeedSkillWhereUniqueInput!]
  disconnect: [NeedSkillWhereUniqueInput!]
  update: [NeedSkillUpdateWithWhereUniqueWithoutJobInput!]
  upsert: [NeedSkillUpsertWithWhereUniqueWithoutJobInput!]
  deleteMany: [NeedSkillScalarWhereInput!]
  updateMany: [NeedSkillUpdateManyWithWhereNestedInput!]
}

input NeedSkillUpdateManyWithWhereNestedInput {
  where: NeedSkillScalarWhereInput!
  data: NeedSkillUpdateManyDataInput!
}

input NeedSkillUpdateWithoutJobDataInput {
  name: String
}

input NeedSkillUpdateWithWhereUniqueWithoutJobInput {
  where: NeedSkillWhereUniqueInput!
  data: NeedSkillUpdateWithoutJobDataInput!
}

input NeedSkillUpsertWithWhereUniqueWithoutJobInput {
  where: NeedSkillWhereUniqueInput!
  update: NeedSkillUpdateWithoutJobDataInput!
  create: NeedSkillCreateWithoutJobInput!
}

input NeedSkillWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  job: JobWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [NeedSkillWhereInput!]
  OR: [NeedSkillWhereInput!]
  NOT: [NeedSkillWhereInput!]
}

input NeedSkillWhereUniqueInput {
  id: ID
}

interface Node {
  id: ID!
}

type Notification {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  body: NotificationBody
  from: User
  seen: Boolean
}

type NotificationBody {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  content: String
}

type NotificationBodyConnection {
  pageInfo: PageInfo!
  edges: [NotificationBodyEdge]!
  aggregate: AggregateNotificationBody!
}

input NotificationBodyCreateInput {
  id: ID
  content: String
}

input NotificationBodyCreateOneInput {
  create: NotificationBodyCreateInput
  connect: NotificationBodyWhereUniqueInput
}

type NotificationBodyEdge {
  node: NotificationBody!
  cursor: String!
}

enum NotificationBodyOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  content_ASC
  content_DESC
}

type NotificationBodyPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  content: String
}

type NotificationBodySubscriptionPayload {
  mutation: MutationType!
  node: NotificationBody
  updatedFields: [String!]
  previousValues: NotificationBodyPreviousValues
}

input NotificationBodySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NotificationBodyWhereInput
  AND: [NotificationBodySubscriptionWhereInput!]
  OR: [NotificationBodySubscriptionWhereInput!]
  NOT: [NotificationBodySubscriptionWhereInput!]
}

input NotificationBodyUpdateDataInput {
  content: String
}

input NotificationBodyUpdateInput {
  content: String
}

input NotificationBodyUpdateManyMutationInput {
  content: String
}

input NotificationBodyUpdateOneInput {
  create: NotificationBodyCreateInput
  update: NotificationBodyUpdateDataInput
  upsert: NotificationBodyUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: NotificationBodyWhereUniqueInput
}

input NotificationBodyUpsertNestedInput {
  update: NotificationBodyUpdateDataInput!
  create: NotificationBodyCreateInput!
}

input NotificationBodyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [NotificationBodyWhereInput!]
  OR: [NotificationBodyWhereInput!]
  NOT: [NotificationBodyWhereInput!]
}

input NotificationBodyWhereUniqueInput {
  id: ID
}

type NotificationConnection {
  pageInfo: PageInfo!
  edges: [NotificationEdge]!
  aggregate: AggregateNotification!
}

input NotificationCreateInput {
  id: ID
  body: NotificationBodyCreateOneInput
  from: UserCreateOneInput
  seen: Boolean
}

type NotificationEdge {
  node: Notification!
  cursor: String!
}

enum NotificationOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  seen_ASC
  seen_DESC
}

type NotificationPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  seen: Boolean
}

type NotificationSubscriptionPayload {
  mutation: MutationType!
  node: Notification
  updatedFields: [String!]
  previousValues: NotificationPreviousValues
}

input NotificationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NotificationWhereInput
  AND: [NotificationSubscriptionWhereInput!]
  OR: [NotificationSubscriptionWhereInput!]
  NOT: [NotificationSubscriptionWhereInput!]
}

input NotificationUpdateInput {
  body: NotificationBodyUpdateOneInput
  from: UserUpdateOneInput
  seen: Boolean
}

input NotificationUpdateManyMutationInput {
  seen: Boolean
}

input NotificationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  body: NotificationBodyWhereInput
  from: UserWhereInput
  seen: Boolean
  seen_not: Boolean
  AND: [NotificationWhereInput!]
  OR: [NotificationWhereInput!]
  NOT: [NotificationWhereInput!]
}

input NotificationWhereUniqueInput {
  id: ID
}

type Offer {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  freelancer: Freelancer!
  job: Job!
  status: StatusOffer
  contactTitle: String
  startDay: String
  workDescription: String
  paymentType: paymentTypeOffer
  proposal: Proposal
}

type OfferConnection {
  pageInfo: PageInfo!
  edges: [OfferEdge]!
  aggregate: AggregateOffer!
}

input OfferCreateInput {
  id: ID
  freelancer: FreelancerCreateOneInput!
  job: JobCreateOneInput!
  status: StatusOffer
  contactTitle: String
  startDay: String
  workDescription: String
  paymentType: paymentTypeOfferCreateOneInput
  proposal: ProposalCreateOneInput
}

input OfferCreateOneInput {
  create: OfferCreateInput
  connect: OfferWhereUniqueInput
}

type OfferEdge {
  node: Offer!
  cursor: String!
}

enum OfferOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  status_ASC
  status_DESC
  contactTitle_ASC
  contactTitle_DESC
  startDay_ASC
  startDay_DESC
  workDescription_ASC
  workDescription_DESC
}

type OfferPreviousValues {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  status: StatusOffer
  contactTitle: String
  startDay: String
  workDescription: String
}

type OfferSubscriptionPayload {
  mutation: MutationType!
  node: Offer
  updatedFields: [String!]
  previousValues: OfferPreviousValues
}

input OfferSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OfferWhereInput
  AND: [OfferSubscriptionWhereInput!]
  OR: [OfferSubscriptionWhereInput!]
  NOT: [OfferSubscriptionWhereInput!]
}

input OfferUpdateDataInput {
  freelancer: FreelancerUpdateOneRequiredInput
  job: JobUpdateOneRequiredInput
  status: StatusOffer
  contactTitle: String
  startDay: String
  workDescription: String
  paymentType: paymentTypeOfferUpdateOneInput
  proposal: ProposalUpdateOneInput
}

input OfferUpdateInput {
  freelancer: FreelancerUpdateOneRequiredInput
  job: JobUpdateOneRequiredInput
  status: StatusOffer
  contactTitle: String
  startDay: String
  workDescription: String
  paymentType: paymentTypeOfferUpdateOneInput
  proposal: ProposalUpdateOneInput
}

input OfferUpdateManyMutationInput {
  status: StatusOffer
  contactTitle: String
  startDay: String
  workDescription: String
}

input OfferUpdateOneRequiredInput {
  create: OfferCreateInput
  update: OfferUpdateDataInput
  upsert: OfferUpsertNestedInput
  connect: OfferWhereUniqueInput
}

input OfferUpsertNestedInput {
  update: OfferUpdateDataInput!
  create: OfferCreateInput!
}

input OfferWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  freelancer: FreelancerWhereInput
  job: JobWhereInput
  status: StatusOffer
  status_not: StatusOffer
  status_in: [StatusOffer!]
  status_not_in: [StatusOffer!]
  contactTitle: String
  contactTitle_not: String
  contactTitle_in: [String!]
  contactTitle_not_in: [String!]
  contactTitle_lt: String
  contactTitle_lte: String
  contactTitle_gt: String
  contactTitle_gte: String
  contactTitle_contains: String
  contactTitle_not_contains: String
  contactTitle_starts_with: String
  contactTitle_not_starts_with: String
  contactTitle_ends_with: String
  contactTitle_not_ends_with: String
  startDay: String
  startDay_not: String
  startDay_in: [String!]
  startDay_not_in: [String!]
  startDay_lt: String
  startDay_lte: String
  startDay_gt: String
  startDay_gte: String
  startDay_contains: String
  startDay_not_contains: String
  startDay_starts_with: String
  startDay_not_starts_with: String
  startDay_ends_with: String
  startDay_not_ends_with: String
  workDescription: String
  workDescription_not: String
  workDescription_in: [String!]
  workDescription_not_in: [String!]
  workDescription_lt: String
  workDescription_lte: String
  workDescription_gt: String
  workDescription_gte: String
  workDescription_contains: String
  workDescription_not_contains: String
  workDescription_starts_with: String
  workDescription_not_starts_with: String
  workDescription_ends_with: String
  workDescription_not_ends_with: String
  paymentType: paymentTypeOfferWhereInput
  proposal: ProposalWhereInput
  AND: [OfferWhereInput!]
  OR: [OfferWhereInput!]
  NOT: [OfferWhereInput!]
}

input OfferWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PaymentForTask {
  id: ID!
  type: PaymentTypeForTask
  budget: Float
}

type PaymentForTaskConnection {
  pageInfo: PageInfo!
  edges: [PaymentForTaskEdge]!
  aggregate: AggregatePaymentForTask!
}

input PaymentForTaskCreateInput {
  id: ID
  type: PaymentTypeForTask
  budget: Float
}

input PaymentForTaskCreateOneInput {
  create: PaymentForTaskCreateInput
  connect: PaymentForTaskWhereUniqueInput
}

type PaymentForTaskEdge {
  node: PaymentForTask!
  cursor: String!
}

enum PaymentForTaskOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  budget_ASC
  budget_DESC
}

type PaymentForTaskPreviousValues {
  id: ID!
  type: PaymentTypeForTask
  budget: Float
}

type PaymentForTaskSubscriptionPayload {
  mutation: MutationType!
  node: PaymentForTask
  updatedFields: [String!]
  previousValues: PaymentForTaskPreviousValues
}

input PaymentForTaskSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentForTaskWhereInput
  AND: [PaymentForTaskSubscriptionWhereInput!]
  OR: [PaymentForTaskSubscriptionWhereInput!]
  NOT: [PaymentForTaskSubscriptionWhereInput!]
}

input PaymentForTaskUpdateDataInput {
  type: PaymentTypeForTask
  budget: Float
}

input PaymentForTaskUpdateInput {
  type: PaymentTypeForTask
  budget: Float
}

input PaymentForTaskUpdateManyMutationInput {
  type: PaymentTypeForTask
  budget: Float
}

input PaymentForTaskUpdateOneRequiredInput {
  create: PaymentForTaskCreateInput
  update: PaymentForTaskUpdateDataInput
  upsert: PaymentForTaskUpsertNestedInput
  connect: PaymentForTaskWhereUniqueInput
}

input PaymentForTaskUpsertNestedInput {
  update: PaymentForTaskUpdateDataInput!
  create: PaymentForTaskCreateInput!
}

input PaymentForTaskWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: PaymentTypeForTask
  type_not: PaymentTypeForTask
  type_in: [PaymentTypeForTask!]
  type_not_in: [PaymentTypeForTask!]
  budget: Float
  budget_not: Float
  budget_in: [Float!]
  budget_not_in: [Float!]
  budget_lt: Float
  budget_lte: Float
  budget_gt: Float
  budget_gte: Float
  AND: [PaymentForTaskWhereInput!]
  OR: [PaymentForTaskWhereInput!]
  NOT: [PaymentForTaskWhereInput!]
}

input PaymentForTaskWhereUniqueInput {
  id: ID
}

enum PaymentTypeForTask {
  HOUR
  FIXED
}

type paymentTypeOffer {
  id: ID!
  type: String
  budget: Float
}

type paymentTypeOfferConnection {
  pageInfo: PageInfo!
  edges: [paymentTypeOfferEdge]!
  aggregate: AggregatepaymentTypeOffer!
}

input paymentTypeOfferCreateInput {
  id: ID
  type: String
  budget: Float
}

input paymentTypeOfferCreateOneInput {
  create: paymentTypeOfferCreateInput
  connect: paymentTypeOfferWhereUniqueInput
}

type paymentTypeOfferEdge {
  node: paymentTypeOffer!
  cursor: String!
}

enum paymentTypeOfferOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  budget_ASC
  budget_DESC
}

type paymentTypeOfferPreviousValues {
  id: ID!
  type: String
  budget: Float
}

type paymentTypeOfferSubscriptionPayload {
  mutation: MutationType!
  node: paymentTypeOffer
  updatedFields: [String!]
  previousValues: paymentTypeOfferPreviousValues
}

input paymentTypeOfferSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: paymentTypeOfferWhereInput
  AND: [paymentTypeOfferSubscriptionWhereInput!]
  OR: [paymentTypeOfferSubscriptionWhereInput!]
  NOT: [paymentTypeOfferSubscriptionWhereInput!]
}

input paymentTypeOfferUpdateDataInput {
  type: String
  budget: Float
}

input paymentTypeOfferUpdateInput {
  type: String
  budget: Float
}

input paymentTypeOfferUpdateManyMutationInput {
  type: String
  budget: Float
}

input paymentTypeOfferUpdateOneInput {
  create: paymentTypeOfferCreateInput
  update: paymentTypeOfferUpdateDataInput
  upsert: paymentTypeOfferUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: paymentTypeOfferWhereUniqueInput
}

input paymentTypeOfferUpsertNestedInput {
  update: paymentTypeOfferUpdateDataInput!
  create: paymentTypeOfferCreateInput!
}

input paymentTypeOfferWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  budget: Float
  budget_not: Float
  budget_in: [Float!]
  budget_not_in: [Float!]
  budget_lt: Float
  budget_lte: Float
  budget_gt: Float
  budget_gte: Float
  AND: [paymentTypeOfferWhereInput!]
  OR: [paymentTypeOfferWhereInput!]
  NOT: [paymentTypeOfferWhereInput!]
}

input paymentTypeOfferWhereUniqueInput {
  id: ID
}

enum Permission {
  FREELANCER
  EMPLOYER
  ADMIN
}

type Portfolio {
  id: ID!
  freelancer: Freelancer
  description: String
  imageUrl: String
  title: String
}

type PortfolioConnection {
  pageInfo: PageInfo!
  edges: [PortfolioEdge]!
  aggregate: AggregatePortfolio!
}

input PortfolioCreateInput {
  id: ID
  freelancer: FreelancerCreateOneWithoutPortfolioInput
  description: String
  imageUrl: String
  title: String
}

input PortfolioCreateManyWithoutFreelancerInput {
  create: [PortfolioCreateWithoutFreelancerInput!]
  connect: [PortfolioWhereUniqueInput!]
}

input PortfolioCreateWithoutFreelancerInput {
  id: ID
  description: String
  imageUrl: String
  title: String
}

type PortfolioEdge {
  node: Portfolio!
  cursor: String!
}

enum PortfolioOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  imageUrl_ASC
  imageUrl_DESC
  title_ASC
  title_DESC
}

type PortfolioPreviousValues {
  id: ID!
  description: String
  imageUrl: String
  title: String
}

input PortfolioScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  imageUrl: String
  imageUrl_not: String
  imageUrl_in: [String!]
  imageUrl_not_in: [String!]
  imageUrl_lt: String
  imageUrl_lte: String
  imageUrl_gt: String
  imageUrl_gte: String
  imageUrl_contains: String
  imageUrl_not_contains: String
  imageUrl_starts_with: String
  imageUrl_not_starts_with: String
  imageUrl_ends_with: String
  imageUrl_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [PortfolioScalarWhereInput!]
  OR: [PortfolioScalarWhereInput!]
  NOT: [PortfolioScalarWhereInput!]
}

type PortfolioSubscriptionPayload {
  mutation: MutationType!
  node: Portfolio
  updatedFields: [String!]
  previousValues: PortfolioPreviousValues
}

input PortfolioSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PortfolioWhereInput
  AND: [PortfolioSubscriptionWhereInput!]
  OR: [PortfolioSubscriptionWhereInput!]
  NOT: [PortfolioSubscriptionWhereInput!]
}

input PortfolioUpdateInput {
  freelancer: FreelancerUpdateOneWithoutPortfolioInput
  description: String
  imageUrl: String
  title: String
}

input PortfolioUpdateManyDataInput {
  description: String
  imageUrl: String
  title: String
}

input PortfolioUpdateManyMutationInput {
  description: String
  imageUrl: String
  title: String
}

input PortfolioUpdateManyWithoutFreelancerInput {
  create: [PortfolioCreateWithoutFreelancerInput!]
  delete: [PortfolioWhereUniqueInput!]
  connect: [PortfolioWhereUniqueInput!]
  set: [PortfolioWhereUniqueInput!]
  disconnect: [PortfolioWhereUniqueInput!]
  update: [PortfolioUpdateWithWhereUniqueWithoutFreelancerInput!]
  upsert: [PortfolioUpsertWithWhereUniqueWithoutFreelancerInput!]
  deleteMany: [PortfolioScalarWhereInput!]
  updateMany: [PortfolioUpdateManyWithWhereNestedInput!]
}

input PortfolioUpdateManyWithWhereNestedInput {
  where: PortfolioScalarWhereInput!
  data: PortfolioUpdateManyDataInput!
}

input PortfolioUpdateWithoutFreelancerDataInput {
  description: String
  imageUrl: String
  title: String
}

input PortfolioUpdateWithWhereUniqueWithoutFreelancerInput {
  where: PortfolioWhereUniqueInput!
  data: PortfolioUpdateWithoutFreelancerDataInput!
}

input PortfolioUpsertWithWhereUniqueWithoutFreelancerInput {
  where: PortfolioWhereUniqueInput!
  update: PortfolioUpdateWithoutFreelancerDataInput!
  create: PortfolioCreateWithoutFreelancerInput!
}

input PortfolioWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  freelancer: FreelancerWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  imageUrl: String
  imageUrl_not: String
  imageUrl_in: [String!]
  imageUrl_not_in: [String!]
  imageUrl_lt: String
  imageUrl_lte: String
  imageUrl_gt: String
  imageUrl_gte: String
  imageUrl_contains: String
  imageUrl_not_contains: String
  imageUrl_starts_with: String
  imageUrl_not_starts_with: String
  imageUrl_ends_with: String
  imageUrl_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [PortfolioWhereInput!]
  OR: [PortfolioWhereInput!]
  NOT: [PortfolioWhereInput!]
}

input PortfolioWhereUniqueInput {
  id: ID
}

type Project {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  title: String!
  job: Job!
  list(where: ListOfProjectWhereInput, orderBy: ListOfProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ListOfProject!]
  status: PROJECT_STATUS!
}

enum PROJECT_STATUS {
  OPEN
  CLOSED
}

type ProjectConnection {
  pageInfo: PageInfo!
  edges: [ProjectEdge]!
  aggregate: AggregateProject!
}

input ProjectCreateInput {
  id: ID
  title: String!
  job: JobCreateOneInput!
  list: ListOfProjectCreateManyWithoutProjectInput
  status: PROJECT_STATUS!
}

input ProjectCreateOneWithoutListInput {
  create: ProjectCreateWithoutListInput
  connect: ProjectWhereUniqueInput
}

input ProjectCreateWithoutListInput {
  id: ID
  title: String!
  job: JobCreateOneInput!
  status: PROJECT_STATUS!
}

type ProjectEdge {
  node: Project!
  cursor: String!
}

enum ProjectOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
  status_ASC
  status_DESC
}

type ProjectPreviousValues {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  title: String!
  status: PROJECT_STATUS!
}

type ProjectSubscriptionPayload {
  mutation: MutationType!
  node: Project
  updatedFields: [String!]
  previousValues: ProjectPreviousValues
}

input ProjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectWhereInput
  AND: [ProjectSubscriptionWhereInput!]
  OR: [ProjectSubscriptionWhereInput!]
  NOT: [ProjectSubscriptionWhereInput!]
}

input ProjectUpdateInput {
  title: String
  job: JobUpdateOneRequiredInput
  list: ListOfProjectUpdateManyWithoutProjectInput
  status: PROJECT_STATUS
}

input ProjectUpdateManyMutationInput {
  title: String
  status: PROJECT_STATUS
}

input ProjectUpdateOneRequiredWithoutListInput {
  create: ProjectCreateWithoutListInput
  update: ProjectUpdateWithoutListDataInput
  upsert: ProjectUpsertWithoutListInput
  connect: ProjectWhereUniqueInput
}

input ProjectUpdateWithoutListDataInput {
  title: String
  job: JobUpdateOneRequiredInput
  status: PROJECT_STATUS
}

input ProjectUpsertWithoutListInput {
  update: ProjectUpdateWithoutListDataInput!
  create: ProjectCreateWithoutListInput!
}

input ProjectWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  job: JobWhereInput
  list_every: ListOfProjectWhereInput
  list_some: ListOfProjectWhereInput
  list_none: ListOfProjectWhereInput
  status: PROJECT_STATUS
  status_not: PROJECT_STATUS
  status_in: [PROJECT_STATUS!]
  status_not_in: [PROJECT_STATUS!]
  AND: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
}

input ProjectWhereUniqueInput {
  id: ID
}

type Proposal {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  freelancer: Freelancer
  coverLetter: String
  attachments(where: AttachmentWhereInput, orderBy: AttachmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attachment!]
  job: Job
  proposalStatus: ProposalStatus
  active: Boolean
  isOffer: Boolean
  isArchived: Boolean
  isShortlist: Boolean
  type: ProposalType
}

type ProposalConnection {
  pageInfo: PageInfo!
  edges: [ProposalEdge]!
  aggregate: AggregateProposal!
}

input ProposalCreateInput {
  id: ID
  freelancer: FreelancerCreateOneInput
  coverLetter: String
  attachments: AttachmentCreateManyInput
  job: JobCreateOneInput
  proposalStatus: ProposalStatus
  active: Boolean
  isOffer: Boolean
  isArchived: Boolean
  isShortlist: Boolean
  type: ProposalType
}

input ProposalCreateOneInput {
  create: ProposalCreateInput
  connect: ProposalWhereUniqueInput
}

type ProposalEdge {
  node: Proposal!
  cursor: String!
}

enum ProposalOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  coverLetter_ASC
  coverLetter_DESC
  proposalStatus_ASC
  proposalStatus_DESC
  active_ASC
  active_DESC
  isOffer_ASC
  isOffer_DESC
  isArchived_ASC
  isArchived_DESC
  isShortlist_ASC
  isShortlist_DESC
  type_ASC
  type_DESC
}

type ProposalPreviousValues {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  coverLetter: String
  proposalStatus: ProposalStatus
  active: Boolean
  isOffer: Boolean
  isArchived: Boolean
  isShortlist: Boolean
  type: ProposalType
}

enum ProposalStatus {
  ACCEPT
  REJECT
  PENDING
}

type ProposalSubscriptionPayload {
  mutation: MutationType!
  node: Proposal
  updatedFields: [String!]
  previousValues: ProposalPreviousValues
}

input ProposalSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProposalWhereInput
  AND: [ProposalSubscriptionWhereInput!]
  OR: [ProposalSubscriptionWhereInput!]
  NOT: [ProposalSubscriptionWhereInput!]
}

enum ProposalType {
  PROPOSAL
  INVITED
}

input ProposalUpdateDataInput {
  freelancer: FreelancerUpdateOneInput
  coverLetter: String
  attachments: AttachmentUpdateManyInput
  job: JobUpdateOneInput
  proposalStatus: ProposalStatus
  active: Boolean
  isOffer: Boolean
  isArchived: Boolean
  isShortlist: Boolean
  type: ProposalType
}

input ProposalUpdateInput {
  freelancer: FreelancerUpdateOneInput
  coverLetter: String
  attachments: AttachmentUpdateManyInput
  job: JobUpdateOneInput
  proposalStatus: ProposalStatus
  active: Boolean
  isOffer: Boolean
  isArchived: Boolean
  isShortlist: Boolean
  type: ProposalType
}

input ProposalUpdateManyMutationInput {
  coverLetter: String
  proposalStatus: ProposalStatus
  active: Boolean
  isOffer: Boolean
  isArchived: Boolean
  isShortlist: Boolean
  type: ProposalType
}

input ProposalUpdateOneInput {
  create: ProposalCreateInput
  update: ProposalUpdateDataInput
  upsert: ProposalUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ProposalWhereUniqueInput
}

input ProposalUpsertNestedInput {
  update: ProposalUpdateDataInput!
  create: ProposalCreateInput!
}

input ProposalWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  freelancer: FreelancerWhereInput
  coverLetter: String
  coverLetter_not: String
  coverLetter_in: [String!]
  coverLetter_not_in: [String!]
  coverLetter_lt: String
  coverLetter_lte: String
  coverLetter_gt: String
  coverLetter_gte: String
  coverLetter_contains: String
  coverLetter_not_contains: String
  coverLetter_starts_with: String
  coverLetter_not_starts_with: String
  coverLetter_ends_with: String
  coverLetter_not_ends_with: String
  attachments_every: AttachmentWhereInput
  attachments_some: AttachmentWhereInput
  attachments_none: AttachmentWhereInput
  job: JobWhereInput
  proposalStatus: ProposalStatus
  proposalStatus_not: ProposalStatus
  proposalStatus_in: [ProposalStatus!]
  proposalStatus_not_in: [ProposalStatus!]
  active: Boolean
  active_not: Boolean
  isOffer: Boolean
  isOffer_not: Boolean
  isArchived: Boolean
  isArchived_not: Boolean
  isShortlist: Boolean
  isShortlist_not: Boolean
  type: ProposalType
  type_not: ProposalType
  type_in: [ProposalType!]
  type_not_in: [ProposalType!]
  AND: [ProposalWhereInput!]
  OR: [ProposalWhereInput!]
  NOT: [ProposalWhereInput!]
}

input ProposalWhereUniqueInput {
  id: ID
}

type Publication {
  id: ID!
  freelancer: Freelancer
  authors: String
  description: String
  publisher: String
  title: String
  url: String
  year: String
}

type PublicationConnection {
  pageInfo: PageInfo!
  edges: [PublicationEdge]!
  aggregate: AggregatePublication!
}

input PublicationCreateInput {
  id: ID
  freelancer: FreelancerCreateOneWithoutPublicationsInput
  authors: String
  description: String
  publisher: String
  title: String
  url: String
  year: String
}

input PublicationCreateManyWithoutFreelancerInput {
  create: [PublicationCreateWithoutFreelancerInput!]
  connect: [PublicationWhereUniqueInput!]
}

input PublicationCreateWithoutFreelancerInput {
  id: ID
  authors: String
  description: String
  publisher: String
  title: String
  url: String
  year: String
}

type PublicationEdge {
  node: Publication!
  cursor: String!
}

enum PublicationOrderByInput {
  id_ASC
  id_DESC
  authors_ASC
  authors_DESC
  description_ASC
  description_DESC
  publisher_ASC
  publisher_DESC
  title_ASC
  title_DESC
  url_ASC
  url_DESC
  year_ASC
  year_DESC
}

type PublicationPreviousValues {
  id: ID!
  authors: String
  description: String
  publisher: String
  title: String
  url: String
  year: String
}

input PublicationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  authors: String
  authors_not: String
  authors_in: [String!]
  authors_not_in: [String!]
  authors_lt: String
  authors_lte: String
  authors_gt: String
  authors_gte: String
  authors_contains: String
  authors_not_contains: String
  authors_starts_with: String
  authors_not_starts_with: String
  authors_ends_with: String
  authors_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  publisher: String
  publisher_not: String
  publisher_in: [String!]
  publisher_not_in: [String!]
  publisher_lt: String
  publisher_lte: String
  publisher_gt: String
  publisher_gte: String
  publisher_contains: String
  publisher_not_contains: String
  publisher_starts_with: String
  publisher_not_starts_with: String
  publisher_ends_with: String
  publisher_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  year: String
  year_not: String
  year_in: [String!]
  year_not_in: [String!]
  year_lt: String
  year_lte: String
  year_gt: String
  year_gte: String
  year_contains: String
  year_not_contains: String
  year_starts_with: String
  year_not_starts_with: String
  year_ends_with: String
  year_not_ends_with: String
  AND: [PublicationScalarWhereInput!]
  OR: [PublicationScalarWhereInput!]
  NOT: [PublicationScalarWhereInput!]
}

type PublicationSubscriptionPayload {
  mutation: MutationType!
  node: Publication
  updatedFields: [String!]
  previousValues: PublicationPreviousValues
}

input PublicationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PublicationWhereInput
  AND: [PublicationSubscriptionWhereInput!]
  OR: [PublicationSubscriptionWhereInput!]
  NOT: [PublicationSubscriptionWhereInput!]
}

input PublicationUpdateInput {
  freelancer: FreelancerUpdateOneWithoutPublicationsInput
  authors: String
  description: String
  publisher: String
  title: String
  url: String
  year: String
}

input PublicationUpdateManyDataInput {
  authors: String
  description: String
  publisher: String
  title: String
  url: String
  year: String
}

input PublicationUpdateManyMutationInput {
  authors: String
  description: String
  publisher: String
  title: String
  url: String
  year: String
}

input PublicationUpdateManyWithoutFreelancerInput {
  create: [PublicationCreateWithoutFreelancerInput!]
  delete: [PublicationWhereUniqueInput!]
  connect: [PublicationWhereUniqueInput!]
  set: [PublicationWhereUniqueInput!]
  disconnect: [PublicationWhereUniqueInput!]
  update: [PublicationUpdateWithWhereUniqueWithoutFreelancerInput!]
  upsert: [PublicationUpsertWithWhereUniqueWithoutFreelancerInput!]
  deleteMany: [PublicationScalarWhereInput!]
  updateMany: [PublicationUpdateManyWithWhereNestedInput!]
}

input PublicationUpdateManyWithWhereNestedInput {
  where: PublicationScalarWhereInput!
  data: PublicationUpdateManyDataInput!
}

input PublicationUpdateWithoutFreelancerDataInput {
  authors: String
  description: String
  publisher: String
  title: String
  url: String
  year: String
}

input PublicationUpdateWithWhereUniqueWithoutFreelancerInput {
  where: PublicationWhereUniqueInput!
  data: PublicationUpdateWithoutFreelancerDataInput!
}

input PublicationUpsertWithWhereUniqueWithoutFreelancerInput {
  where: PublicationWhereUniqueInput!
  update: PublicationUpdateWithoutFreelancerDataInput!
  create: PublicationCreateWithoutFreelancerInput!
}

input PublicationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  freelancer: FreelancerWhereInput
  authors: String
  authors_not: String
  authors_in: [String!]
  authors_not_in: [String!]
  authors_lt: String
  authors_lte: String
  authors_gt: String
  authors_gte: String
  authors_contains: String
  authors_not_contains: String
  authors_starts_with: String
  authors_not_starts_with: String
  authors_ends_with: String
  authors_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  publisher: String
  publisher_not: String
  publisher_in: [String!]
  publisher_not_in: [String!]
  publisher_lt: String
  publisher_lte: String
  publisher_gt: String
  publisher_gte: String
  publisher_contains: String
  publisher_not_contains: String
  publisher_starts_with: String
  publisher_not_starts_with: String
  publisher_ends_with: String
  publisher_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  year: String
  year_not: String
  year_in: [String!]
  year_not_in: [String!]
  year_lt: String
  year_lte: String
  year_gt: String
  year_gte: String
  year_contains: String
  year_not_contains: String
  year_starts_with: String
  year_not_starts_with: String
  year_ends_with: String
  year_not_ends_with: String
  AND: [PublicationWhereInput!]
  OR: [PublicationWhereInput!]
  NOT: [PublicationWhereInput!]
}

input PublicationWhereUniqueInput {
  id: ID
}

type Query {
  assign(where: AssignWhereUniqueInput!): Assign
  assigns(where: AssignWhereInput, orderBy: AssignOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Assign]!
  assignsConnection(where: AssignWhereInput, orderBy: AssignOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AssignConnection!
  attachment(where: AttachmentWhereUniqueInput!): Attachment
  attachments(where: AttachmentWhereInput, orderBy: AttachmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attachment]!
  attachmentsConnection(where: AttachmentWhereInput, orderBy: AttachmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AttachmentConnection!
  category(where: CategoryWhereUniqueInput!): Category
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  certification(where: CertificationWhereUniqueInput!): Certification
  certifications(where: CertificationWhereInput, orderBy: CertificationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Certification]!
  certificationsConnection(where: CertificationWhereInput, orderBy: CertificationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CertificationConnection!
  company(where: CompanyWhereUniqueInput!): Company
  companies(where: CompanyWhereInput, orderBy: CompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Company]!
  companiesConnection(where: CompanyWhereInput, orderBy: CompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CompanyConnection!
  contact(where: ContactWhereUniqueInput!): Contact
  contacts(where: ContactWhereInput, orderBy: ContactOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Contact]!
  contactsConnection(where: ContactWhereInput, orderBy: ContactOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContactConnection!
  conversation(where: ConversationWhereUniqueInput!): Conversation
  conversations(where: ConversationWhereInput, orderBy: ConversationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Conversation]!
  conversationsConnection(where: ConversationWhereInput, orderBy: ConversationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ConversationConnection!
  education(where: EducationWhereUniqueInput!): Education
  educations(where: EducationWhereInput, orderBy: EducationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Education]!
  educationsConnection(where: EducationWhereInput, orderBy: EducationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EducationConnection!
  employer(where: EmployerWhereUniqueInput!): Employer
  employers(where: EmployerWhereInput, orderBy: EmployerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Employer]!
  employersConnection(where: EmployerWhereInput, orderBy: EmployerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EmployerConnection!
  employerShortList(where: EmployerShortListWhereUniqueInput!): EmployerShortList
  employerShortLists(where: EmployerShortListWhereInput, orderBy: EmployerShortListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [EmployerShortList]!
  employerShortListsConnection(where: EmployerShortListWhereInput, orderBy: EmployerShortListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EmployerShortListConnection!
  experience(where: ExperienceWhereUniqueInput!): Experience
  experiences(where: ExperienceWhereInput, orderBy: ExperienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Experience]!
  experiencesConnection(where: ExperienceWhereInput, orderBy: ExperienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExperienceConnection!
  freelancer(where: FreelancerWhereUniqueInput!): Freelancer
  freelancers(where: FreelancerWhereInput, orderBy: FreelancerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Freelancer]!
  freelancersConnection(where: FreelancerWhereInput, orderBy: FreelancerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FreelancerConnection!
  freelancerShortList(where: FreelancerShortListWhereUniqueInput!): FreelancerShortList
  freelancerShortLists(where: FreelancerShortListWhereInput, orderBy: FreelancerShortListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FreelancerShortList]!
  freelancerShortListsConnection(where: FreelancerShortListWhereInput, orderBy: FreelancerShortListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FreelancerShortListConnection!
  hire(where: HireWhereUniqueInput!): Hire
  hires(where: HireWhereInput, orderBy: HireOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Hire]!
  hiresConnection(where: HireWhereInput, orderBy: HireOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HireConnection!
  interview(where: InterviewWhereUniqueInput!): Interview
  interviews(where: InterviewWhereInput, orderBy: InterviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Interview]!
  interviewsConnection(where: InterviewWhereInput, orderBy: InterviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InterviewConnection!
  job(where: JobWhereUniqueInput!): Job
  jobs(where: JobWhereInput, orderBy: JobOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Job]!
  jobsConnection(where: JobWhereInput, orderBy: JobOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): JobConnection!
  languageSkill(where: LanguageSkillWhereUniqueInput!): LanguageSkill
  languageSkills(where: LanguageSkillWhereInput, orderBy: LanguageSkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LanguageSkill]!
  languageSkillsConnection(where: LanguageSkillWhereInput, orderBy: LanguageSkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LanguageSkillConnection!
  listOfProject(where: ListOfProjectWhereUniqueInput!): ListOfProject
  listOfProjects(where: ListOfProjectWhereInput, orderBy: ListOfProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ListOfProject]!
  listOfProjectsConnection(where: ListOfProjectWhereInput, orderBy: ListOfProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ListOfProjectConnection!
  needSkill(where: NeedSkillWhereUniqueInput!): NeedSkill
  needSkills(where: NeedSkillWhereInput, orderBy: NeedSkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NeedSkill]!
  needSkillsConnection(where: NeedSkillWhereInput, orderBy: NeedSkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NeedSkillConnection!
  notification(where: NotificationWhereUniqueInput!): Notification
  notifications(where: NotificationWhereInput, orderBy: NotificationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Notification]!
  notificationsConnection(where: NotificationWhereInput, orderBy: NotificationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NotificationConnection!
  notificationBody(where: NotificationBodyWhereUniqueInput!): NotificationBody
  notificationBodies(where: NotificationBodyWhereInput, orderBy: NotificationBodyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NotificationBody]!
  notificationBodiesConnection(where: NotificationBodyWhereInput, orderBy: NotificationBodyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NotificationBodyConnection!
  offer(where: OfferWhereUniqueInput!): Offer
  offers(where: OfferWhereInput, orderBy: OfferOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Offer]!
  offersConnection(where: OfferWhereInput, orderBy: OfferOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OfferConnection!
  paymentForTask(where: PaymentForTaskWhereUniqueInput!): PaymentForTask
  paymentForTasks(where: PaymentForTaskWhereInput, orderBy: PaymentForTaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PaymentForTask]!
  paymentForTasksConnection(where: PaymentForTaskWhereInput, orderBy: PaymentForTaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentForTaskConnection!
  portfolio(where: PortfolioWhereUniqueInput!): Portfolio
  portfolios(where: PortfolioWhereInput, orderBy: PortfolioOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Portfolio]!
  portfoliosConnection(where: PortfolioWhereInput, orderBy: PortfolioOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PortfolioConnection!
  project(where: ProjectWhereUniqueInput!): Project
  projects(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Project]!
  projectsConnection(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectConnection!
  proposal(where: ProposalWhereUniqueInput!): Proposal
  proposals(where: ProposalWhereInput, orderBy: ProposalOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Proposal]!
  proposalsConnection(where: ProposalWhereInput, orderBy: ProposalOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProposalConnection!
  publication(where: PublicationWhereUniqueInput!): Publication
  publications(where: PublicationWhereInput, orderBy: PublicationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Publication]!
  publicationsConnection(where: PublicationWhereInput, orderBy: PublicationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PublicationConnection!
  skill(where: SkillWhereUniqueInput!): Skill
  skills(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Skill]!
  skillsConnection(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SkillConnection!
  task(where: TaskWhereUniqueInput!): Task
  tasks(where: TaskWhereInput, orderBy: TaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Task]!
  tasksConnection(where: TaskWhereInput, orderBy: TaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TaskConnection!
  test(where: TestWhereUniqueInput!): Test
  tests(where: TestWhereInput, orderBy: TestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Test]!
  testsConnection(where: TestWhereInput, orderBy: TestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TestConnection!
  text(where: TextWhereUniqueInput!): Text
  texts(where: TextWhereInput, orderBy: TextOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Text]!
  textsConnection(where: TextWhereInput, orderBy: TextOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TextConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  employerInvitedFreelancer(where: employerInvitedFreelancerWhereUniqueInput!): employerInvitedFreelancer
  employerInvitedFreelancers(where: employerInvitedFreelancerWhereInput, orderBy: employerInvitedFreelancerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [employerInvitedFreelancer]!
  employerInvitedFreelancersConnection(where: employerInvitedFreelancerWhereInput, orderBy: employerInvitedFreelancerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): employerInvitedFreelancerConnection!
  paymentTypeOffer(where: paymentTypeOfferWhereUniqueInput!): paymentTypeOffer
  paymentTypeOffers(where: paymentTypeOfferWhereInput, orderBy: paymentTypeOfferOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [paymentTypeOffer]!
  paymentTypeOffersConnection(where: paymentTypeOfferWhereInput, orderBy: paymentTypeOfferOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): paymentTypeOfferConnection!
  node(id: ID!): Node
}

type Skill {
  id: ID!
  freelancer(where: FreelancerWhereInput, orderBy: FreelancerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Freelancer!]
  nameSkill: String
  expYears: Int
}

type SkillConnection {
  pageInfo: PageInfo!
  edges: [SkillEdge]!
  aggregate: AggregateSkill!
}

input SkillCreateInput {
  id: ID
  freelancer: FreelancerCreateManyWithoutSkillsInput
  nameSkill: String
  expYears: Int
}

input SkillCreateManyInput {
  create: [SkillCreateInput!]
  connect: [SkillWhereUniqueInput!]
}

input SkillCreateManyWithoutFreelancerInput {
  create: [SkillCreateWithoutFreelancerInput!]
  connect: [SkillWhereUniqueInput!]
}

input SkillCreateWithoutFreelancerInput {
  id: ID
  nameSkill: String
  expYears: Int
}

type SkillEdge {
  node: Skill!
  cursor: String!
}

enum SkillOrderByInput {
  id_ASC
  id_DESC
  nameSkill_ASC
  nameSkill_DESC
  expYears_ASC
  expYears_DESC
}

type SkillPreviousValues {
  id: ID!
  nameSkill: String
  expYears: Int
}

input SkillScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  nameSkill: String
  nameSkill_not: String
  nameSkill_in: [String!]
  nameSkill_not_in: [String!]
  nameSkill_lt: String
  nameSkill_lte: String
  nameSkill_gt: String
  nameSkill_gte: String
  nameSkill_contains: String
  nameSkill_not_contains: String
  nameSkill_starts_with: String
  nameSkill_not_starts_with: String
  nameSkill_ends_with: String
  nameSkill_not_ends_with: String
  expYears: Int
  expYears_not: Int
  expYears_in: [Int!]
  expYears_not_in: [Int!]
  expYears_lt: Int
  expYears_lte: Int
  expYears_gt: Int
  expYears_gte: Int
  AND: [SkillScalarWhereInput!]
  OR: [SkillScalarWhereInput!]
  NOT: [SkillScalarWhereInput!]
}

type SkillSubscriptionPayload {
  mutation: MutationType!
  node: Skill
  updatedFields: [String!]
  previousValues: SkillPreviousValues
}

input SkillSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SkillWhereInput
  AND: [SkillSubscriptionWhereInput!]
  OR: [SkillSubscriptionWhereInput!]
  NOT: [SkillSubscriptionWhereInput!]
}

input SkillUpdateDataInput {
  freelancer: FreelancerUpdateManyWithoutSkillsInput
  nameSkill: String
  expYears: Int
}

input SkillUpdateInput {
  freelancer: FreelancerUpdateManyWithoutSkillsInput
  nameSkill: String
  expYears: Int
}

input SkillUpdateManyDataInput {
  nameSkill: String
  expYears: Int
}

input SkillUpdateManyInput {
  create: [SkillCreateInput!]
  update: [SkillUpdateWithWhereUniqueNestedInput!]
  upsert: [SkillUpsertWithWhereUniqueNestedInput!]
  delete: [SkillWhereUniqueInput!]
  connect: [SkillWhereUniqueInput!]
  set: [SkillWhereUniqueInput!]
  disconnect: [SkillWhereUniqueInput!]
  deleteMany: [SkillScalarWhereInput!]
  updateMany: [SkillUpdateManyWithWhereNestedInput!]
}

input SkillUpdateManyMutationInput {
  nameSkill: String
  expYears: Int
}

input SkillUpdateManyWithoutFreelancerInput {
  create: [SkillCreateWithoutFreelancerInput!]
  delete: [SkillWhereUniqueInput!]
  connect: [SkillWhereUniqueInput!]
  set: [SkillWhereUniqueInput!]
  disconnect: [SkillWhereUniqueInput!]
  update: [SkillUpdateWithWhereUniqueWithoutFreelancerInput!]
  upsert: [SkillUpsertWithWhereUniqueWithoutFreelancerInput!]
  deleteMany: [SkillScalarWhereInput!]
  updateMany: [SkillUpdateManyWithWhereNestedInput!]
}

input SkillUpdateManyWithWhereNestedInput {
  where: SkillScalarWhereInput!
  data: SkillUpdateManyDataInput!
}

input SkillUpdateWithoutFreelancerDataInput {
  nameSkill: String
  expYears: Int
}

input SkillUpdateWithWhereUniqueNestedInput {
  where: SkillWhereUniqueInput!
  data: SkillUpdateDataInput!
}

input SkillUpdateWithWhereUniqueWithoutFreelancerInput {
  where: SkillWhereUniqueInput!
  data: SkillUpdateWithoutFreelancerDataInput!
}

input SkillUpsertWithWhereUniqueNestedInput {
  where: SkillWhereUniqueInput!
  update: SkillUpdateDataInput!
  create: SkillCreateInput!
}

input SkillUpsertWithWhereUniqueWithoutFreelancerInput {
  where: SkillWhereUniqueInput!
  update: SkillUpdateWithoutFreelancerDataInput!
  create: SkillCreateWithoutFreelancerInput!
}

input SkillWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  freelancer_every: FreelancerWhereInput
  freelancer_some: FreelancerWhereInput
  freelancer_none: FreelancerWhereInput
  nameSkill: String
  nameSkill_not: String
  nameSkill_in: [String!]
  nameSkill_not_in: [String!]
  nameSkill_lt: String
  nameSkill_lte: String
  nameSkill_gt: String
  nameSkill_gte: String
  nameSkill_contains: String
  nameSkill_not_contains: String
  nameSkill_starts_with: String
  nameSkill_not_starts_with: String
  nameSkill_ends_with: String
  nameSkill_not_ends_with: String
  expYears: Int
  expYears_not: Int
  expYears_in: [Int!]
  expYears_not_in: [Int!]
  expYears_lt: Int
  expYears_lte: Int
  expYears_gt: Int
  expYears_gte: Int
  AND: [SkillWhereInput!]
  OR: [SkillWhereInput!]
  NOT: [SkillWhereInput!]
}

input SkillWhereUniqueInput {
  id: ID
}

enum StatusOffer {
  PENDING
  SENT
  DRAFT
  DELETED
  ACCEPTED
  REJECTED
}

type Subscription {
  assign(where: AssignSubscriptionWhereInput): AssignSubscriptionPayload
  attachment(where: AttachmentSubscriptionWhereInput): AttachmentSubscriptionPayload
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  certification(where: CertificationSubscriptionWhereInput): CertificationSubscriptionPayload
  company(where: CompanySubscriptionWhereInput): CompanySubscriptionPayload
  contact(where: ContactSubscriptionWhereInput): ContactSubscriptionPayload
  conversation(where: ConversationSubscriptionWhereInput): ConversationSubscriptionPayload
  education(where: EducationSubscriptionWhereInput): EducationSubscriptionPayload
  employer(where: EmployerSubscriptionWhereInput): EmployerSubscriptionPayload
  employerShortList(where: EmployerShortListSubscriptionWhereInput): EmployerShortListSubscriptionPayload
  experience(where: ExperienceSubscriptionWhereInput): ExperienceSubscriptionPayload
  freelancer(where: FreelancerSubscriptionWhereInput): FreelancerSubscriptionPayload
  freelancerShortList(where: FreelancerShortListSubscriptionWhereInput): FreelancerShortListSubscriptionPayload
  hire(where: HireSubscriptionWhereInput): HireSubscriptionPayload
  interview(where: InterviewSubscriptionWhereInput): InterviewSubscriptionPayload
  job(where: JobSubscriptionWhereInput): JobSubscriptionPayload
  languageSkill(where: LanguageSkillSubscriptionWhereInput): LanguageSkillSubscriptionPayload
  listOfProject(where: ListOfProjectSubscriptionWhereInput): ListOfProjectSubscriptionPayload
  needSkill(where: NeedSkillSubscriptionWhereInput): NeedSkillSubscriptionPayload
  notification(where: NotificationSubscriptionWhereInput): NotificationSubscriptionPayload
  notificationBody(where: NotificationBodySubscriptionWhereInput): NotificationBodySubscriptionPayload
  offer(where: OfferSubscriptionWhereInput): OfferSubscriptionPayload
  paymentForTask(where: PaymentForTaskSubscriptionWhereInput): PaymentForTaskSubscriptionPayload
  portfolio(where: PortfolioSubscriptionWhereInput): PortfolioSubscriptionPayload
  project(where: ProjectSubscriptionWhereInput): ProjectSubscriptionPayload
  proposal(where: ProposalSubscriptionWhereInput): ProposalSubscriptionPayload
  publication(where: PublicationSubscriptionWhereInput): PublicationSubscriptionPayload
  skill(where: SkillSubscriptionWhereInput): SkillSubscriptionPayload
  task(where: TaskSubscriptionWhereInput): TaskSubscriptionPayload
  test(where: TestSubscriptionWhereInput): TestSubscriptionPayload
  text(where: TextSubscriptionWhereInput): TextSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  employerInvitedFreelancer(where: employerInvitedFreelancerSubscriptionWhereInput): employerInvitedFreelancerSubscriptionPayload
  paymentTypeOffer(where: paymentTypeOfferSubscriptionWhereInput): paymentTypeOfferSubscriptionPayload
}

type Task {
  id: ID!
  job: Job!
  createdAt: DateTime
  updatedAt: DateTime
  title: String!
  description: String!
  assign(where: AssignWhereInput, orderBy: AssignOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Assign!]
  attachments(where: AttachmentWhereInput, orderBy: AttachmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attachment!]
  dueDate: [String!]!
  billing: PaymentForTask!
  screenShot: Boolean
  trackingTime: Boolean
  status: TaskStatus
}

type TaskConnection {
  pageInfo: PageInfo!
  edges: [TaskEdge]!
  aggregate: AggregateTask!
}

input TaskCreatedueDateInput {
  set: [String!]
}

input TaskCreateInput {
  id: ID
  job: JobCreateOneInput!
  title: String!
  description: String!
  assign: AssignCreateManyWithoutTaskInput
  attachments: AttachmentCreateManyInput
  dueDate: TaskCreatedueDateInput
  billing: PaymentForTaskCreateOneInput!
  screenShot: Boolean
  trackingTime: Boolean
  status: TaskStatus
}

input TaskCreateManyInput {
  create: [TaskCreateInput!]
  connect: [TaskWhereUniqueInput!]
}

input TaskCreateOneWithoutAssignInput {
  create: TaskCreateWithoutAssignInput
  connect: TaskWhereUniqueInput
}

input TaskCreateWithoutAssignInput {
  id: ID
  job: JobCreateOneInput!
  title: String!
  description: String!
  attachments: AttachmentCreateManyInput
  dueDate: TaskCreatedueDateInput
  billing: PaymentForTaskCreateOneInput!
  screenShot: Boolean
  trackingTime: Boolean
  status: TaskStatus
}

type TaskEdge {
  node: Task!
  cursor: String!
}

enum TaskOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  screenShot_ASC
  screenShot_DESC
  trackingTime_ASC
  trackingTime_DESC
  status_ASC
  status_DESC
}

type TaskPreviousValues {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  title: String!
  description: String!
  dueDate: [String!]!
  screenShot: Boolean
  trackingTime: Boolean
  status: TaskStatus
}

input TaskScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  screenShot: Boolean
  screenShot_not: Boolean
  trackingTime: Boolean
  trackingTime_not: Boolean
  status: TaskStatus
  status_not: TaskStatus
  status_in: [TaskStatus!]
  status_not_in: [TaskStatus!]
  AND: [TaskScalarWhereInput!]
  OR: [TaskScalarWhereInput!]
  NOT: [TaskScalarWhereInput!]
}

enum TaskStatus {
  ACTIVE
  COMPLETED
  ARCHIVED
}

type TaskSubscriptionPayload {
  mutation: MutationType!
  node: Task
  updatedFields: [String!]
  previousValues: TaskPreviousValues
}

input TaskSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TaskWhereInput
  AND: [TaskSubscriptionWhereInput!]
  OR: [TaskSubscriptionWhereInput!]
  NOT: [TaskSubscriptionWhereInput!]
}

input TaskUpdateDataInput {
  job: JobUpdateOneRequiredInput
  title: String
  description: String
  assign: AssignUpdateManyWithoutTaskInput
  attachments: AttachmentUpdateManyInput
  dueDate: TaskUpdatedueDateInput
  billing: PaymentForTaskUpdateOneRequiredInput
  screenShot: Boolean
  trackingTime: Boolean
  status: TaskStatus
}

input TaskUpdatedueDateInput {
  set: [String!]
}

input TaskUpdateInput {
  job: JobUpdateOneRequiredInput
  title: String
  description: String
  assign: AssignUpdateManyWithoutTaskInput
  attachments: AttachmentUpdateManyInput
  dueDate: TaskUpdatedueDateInput
  billing: PaymentForTaskUpdateOneRequiredInput
  screenShot: Boolean
  trackingTime: Boolean
  status: TaskStatus
}

input TaskUpdateManyDataInput {
  title: String
  description: String
  dueDate: TaskUpdatedueDateInput
  screenShot: Boolean
  trackingTime: Boolean
  status: TaskStatus
}

input TaskUpdateManyInput {
  create: [TaskCreateInput!]
  update: [TaskUpdateWithWhereUniqueNestedInput!]
  upsert: [TaskUpsertWithWhereUniqueNestedInput!]
  delete: [TaskWhereUniqueInput!]
  connect: [TaskWhereUniqueInput!]
  set: [TaskWhereUniqueInput!]
  disconnect: [TaskWhereUniqueInput!]
  deleteMany: [TaskScalarWhereInput!]
  updateMany: [TaskUpdateManyWithWhereNestedInput!]
}

input TaskUpdateManyMutationInput {
  title: String
  description: String
  dueDate: TaskUpdatedueDateInput
  screenShot: Boolean
  trackingTime: Boolean
  status: TaskStatus
}

input TaskUpdateManyWithWhereNestedInput {
  where: TaskScalarWhereInput!
  data: TaskUpdateManyDataInput!
}

input TaskUpdateOneWithoutAssignInput {
  create: TaskCreateWithoutAssignInput
  update: TaskUpdateWithoutAssignDataInput
  upsert: TaskUpsertWithoutAssignInput
  delete: Boolean
  disconnect: Boolean
  connect: TaskWhereUniqueInput
}

input TaskUpdateWithoutAssignDataInput {
  job: JobUpdateOneRequiredInput
  title: String
  description: String
  attachments: AttachmentUpdateManyInput
  dueDate: TaskUpdatedueDateInput
  billing: PaymentForTaskUpdateOneRequiredInput
  screenShot: Boolean
  trackingTime: Boolean
  status: TaskStatus
}

input TaskUpdateWithWhereUniqueNestedInput {
  where: TaskWhereUniqueInput!
  data: TaskUpdateDataInput!
}

input TaskUpsertWithoutAssignInput {
  update: TaskUpdateWithoutAssignDataInput!
  create: TaskCreateWithoutAssignInput!
}

input TaskUpsertWithWhereUniqueNestedInput {
  where: TaskWhereUniqueInput!
  update: TaskUpdateDataInput!
  create: TaskCreateInput!
}

input TaskWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  job: JobWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  assign_every: AssignWhereInput
  assign_some: AssignWhereInput
  assign_none: AssignWhereInput
  attachments_every: AttachmentWhereInput
  attachments_some: AttachmentWhereInput
  attachments_none: AttachmentWhereInput
  billing: PaymentForTaskWhereInput
  screenShot: Boolean
  screenShot_not: Boolean
  trackingTime: Boolean
  trackingTime_not: Boolean
  status: TaskStatus
  status_not: TaskStatus
  status_in: [TaskStatus!]
  status_not_in: [TaskStatus!]
  AND: [TaskWhereInput!]
  OR: [TaskWhereInput!]
  NOT: [TaskWhereInput!]
}

input TaskWhereUniqueInput {
  id: ID
}

type Test {
  id: ID!
  message: String
}

type TestConnection {
  pageInfo: PageInfo!
  edges: [TestEdge]!
  aggregate: AggregateTest!
}

input TestCreateInput {
  id: ID
  message: String
}

type TestEdge {
  node: Test!
  cursor: String!
}

enum TestOrderByInput {
  id_ASC
  id_DESC
  message_ASC
  message_DESC
}

type TestPreviousValues {
  id: ID!
  message: String
}

type TestSubscriptionPayload {
  mutation: MutationType!
  node: Test
  updatedFields: [String!]
  previousValues: TestPreviousValues
}

input TestSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TestWhereInput
  AND: [TestSubscriptionWhereInput!]
  OR: [TestSubscriptionWhereInput!]
  NOT: [TestSubscriptionWhereInput!]
}

input TestUpdateInput {
  message: String
}

input TestUpdateManyMutationInput {
  message: String
}

input TestWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  AND: [TestWhereInput!]
  OR: [TestWhereInput!]
  NOT: [TestWhereInput!]
}

input TestWhereUniqueInput {
  id: ID
}

type Text {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  type: MessageType
  text: String
  attachments(where: AttachmentWhereInput, orderBy: AttachmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attachment!]
  author: User!
  conversation: Conversation!
}

type TextConnection {
  pageInfo: PageInfo!
  edges: [TextEdge]!
  aggregate: AggregateText!
}

input TextCreateInput {
  id: ID
  type: MessageType
  text: String
  attachments: AttachmentCreateManyInput
  author: UserCreateOneInput!
  conversation: ConversationCreateOneWithoutTextsInput!
}

input TextCreateManyWithoutConversationInput {
  create: [TextCreateWithoutConversationInput!]
  connect: [TextWhereUniqueInput!]
}

input TextCreateWithoutConversationInput {
  id: ID
  type: MessageType
  text: String
  attachments: AttachmentCreateManyInput
  author: UserCreateOneInput!
}

type TextEdge {
  node: Text!
  cursor: String!
}

enum TextOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  type_ASC
  type_DESC
  text_ASC
  text_DESC
}

type TextPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  type: MessageType
  text: String
}

input TextScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  type: MessageType
  type_not: MessageType
  type_in: [MessageType!]
  type_not_in: [MessageType!]
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [TextScalarWhereInput!]
  OR: [TextScalarWhereInput!]
  NOT: [TextScalarWhereInput!]
}

type TextSubscriptionPayload {
  mutation: MutationType!
  node: Text
  updatedFields: [String!]
  previousValues: TextPreviousValues
}

input TextSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TextWhereInput
  AND: [TextSubscriptionWhereInput!]
  OR: [TextSubscriptionWhereInput!]
  NOT: [TextSubscriptionWhereInput!]
}

input TextUpdateInput {
  type: MessageType
  text: String
  attachments: AttachmentUpdateManyInput
  author: UserUpdateOneRequiredInput
  conversation: ConversationUpdateOneRequiredWithoutTextsInput
}

input TextUpdateManyDataInput {
  type: MessageType
  text: String
}

input TextUpdateManyMutationInput {
  type: MessageType
  text: String
}

input TextUpdateManyWithoutConversationInput {
  create: [TextCreateWithoutConversationInput!]
  delete: [TextWhereUniqueInput!]
  connect: [TextWhereUniqueInput!]
  set: [TextWhereUniqueInput!]
  disconnect: [TextWhereUniqueInput!]
  update: [TextUpdateWithWhereUniqueWithoutConversationInput!]
  upsert: [TextUpsertWithWhereUniqueWithoutConversationInput!]
  deleteMany: [TextScalarWhereInput!]
  updateMany: [TextUpdateManyWithWhereNestedInput!]
}

input TextUpdateManyWithWhereNestedInput {
  where: TextScalarWhereInput!
  data: TextUpdateManyDataInput!
}

input TextUpdateWithoutConversationDataInput {
  type: MessageType
  text: String
  attachments: AttachmentUpdateManyInput
  author: UserUpdateOneRequiredInput
}

input TextUpdateWithWhereUniqueWithoutConversationInput {
  where: TextWhereUniqueInput!
  data: TextUpdateWithoutConversationDataInput!
}

input TextUpsertWithWhereUniqueWithoutConversationInput {
  where: TextWhereUniqueInput!
  update: TextUpdateWithoutConversationDataInput!
  create: TextCreateWithoutConversationInput!
}

input TextWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  type: MessageType
  type_not: MessageType
  type_in: [MessageType!]
  type_not_in: [MessageType!]
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  attachments_every: AttachmentWhereInput
  attachments_some: AttachmentWhereInput
  attachments_none: AttachmentWhereInput
  author: UserWhereInput
  conversation: ConversationWhereInput
  AND: [TextWhereInput!]
  OR: [TextWhereInput!]
  NOT: [TextWhereInput!]
}

input TextWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  urlAvatar: String
  isOnline: Boolean
  lastTimeOnl: DateTime
  freelancer: Freelancer
  employer: Employer
  fullName: String
  email: String
  userName: String
  password: String
  resetToken: String
  resetTokenExpiry: Float
  permissions: [Permission!]!
  conversations(where: ConversationWhereInput, orderBy: ConversationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Conversation!]
  active: Boolean
  tags: [String!]!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  urlAvatar: String
  isOnline: Boolean
  lastTimeOnl: DateTime
  freelancer: FreelancerCreateOneWithoutUserInput
  employer: EmployerCreateOneWithoutUserInput
  fullName: String
  email: String
  userName: String
  password: String
  resetToken: String
  resetTokenExpiry: Float
  permissions: UserCreatepermissionsInput
  conversations: ConversationCreateManyWithoutParticipantsInput
  active: Boolean
  tags: UserCreatetagsInput
}

input UserCreateManyWithoutConversationsInput {
  create: [UserCreateWithoutConversationsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutEmployerInput {
  create: UserCreateWithoutEmployerInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutFreelancerInput {
  create: UserCreateWithoutFreelancerInput
  connect: UserWhereUniqueInput
}

input UserCreatepermissionsInput {
  set: [Permission!]
}

input UserCreatetagsInput {
  set: [String!]
}

input UserCreateWithoutConversationsInput {
  id: ID
  urlAvatar: String
  isOnline: Boolean
  lastTimeOnl: DateTime
  freelancer: FreelancerCreateOneWithoutUserInput
  employer: EmployerCreateOneWithoutUserInput
  fullName: String
  email: String
  userName: String
  password: String
  resetToken: String
  resetTokenExpiry: Float
  permissions: UserCreatepermissionsInput
  active: Boolean
  tags: UserCreatetagsInput
}

input UserCreateWithoutEmployerInput {
  id: ID
  urlAvatar: String
  isOnline: Boolean
  lastTimeOnl: DateTime
  freelancer: FreelancerCreateOneWithoutUserInput
  fullName: String
  email: String
  userName: String
  password: String
  resetToken: String
  resetTokenExpiry: Float
  permissions: UserCreatepermissionsInput
  conversations: ConversationCreateManyWithoutParticipantsInput
  active: Boolean
  tags: UserCreatetagsInput
}

input UserCreateWithoutFreelancerInput {
  id: ID
  urlAvatar: String
  isOnline: Boolean
  lastTimeOnl: DateTime
  employer: EmployerCreateOneWithoutUserInput
  fullName: String
  email: String
  userName: String
  password: String
  resetToken: String
  resetTokenExpiry: Float
  permissions: UserCreatepermissionsInput
  conversations: ConversationCreateManyWithoutParticipantsInput
  active: Boolean
  tags: UserCreatetagsInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  urlAvatar_ASC
  urlAvatar_DESC
  isOnline_ASC
  isOnline_DESC
  lastTimeOnl_ASC
  lastTimeOnl_DESC
  fullName_ASC
  fullName_DESC
  email_ASC
  email_DESC
  userName_ASC
  userName_DESC
  password_ASC
  password_DESC
  resetToken_ASC
  resetToken_DESC
  resetTokenExpiry_ASC
  resetTokenExpiry_DESC
  active_ASC
  active_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  urlAvatar: String
  isOnline: Boolean
  lastTimeOnl: DateTime
  fullName: String
  email: String
  userName: String
  password: String
  resetToken: String
  resetTokenExpiry: Float
  permissions: [Permission!]!
  active: Boolean
  tags: [String!]!
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  urlAvatar: String
  urlAvatar_not: String
  urlAvatar_in: [String!]
  urlAvatar_not_in: [String!]
  urlAvatar_lt: String
  urlAvatar_lte: String
  urlAvatar_gt: String
  urlAvatar_gte: String
  urlAvatar_contains: String
  urlAvatar_not_contains: String
  urlAvatar_starts_with: String
  urlAvatar_not_starts_with: String
  urlAvatar_ends_with: String
  urlAvatar_not_ends_with: String
  isOnline: Boolean
  isOnline_not: Boolean
  lastTimeOnl: DateTime
  lastTimeOnl_not: DateTime
  lastTimeOnl_in: [DateTime!]
  lastTimeOnl_not_in: [DateTime!]
  lastTimeOnl_lt: DateTime
  lastTimeOnl_lte: DateTime
  lastTimeOnl_gt: DateTime
  lastTimeOnl_gte: DateTime
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  userName: String
  userName_not: String
  userName_in: [String!]
  userName_not_in: [String!]
  userName_lt: String
  userName_lte: String
  userName_gt: String
  userName_gte: String
  userName_contains: String
  userName_not_contains: String
  userName_starts_with: String
  userName_not_starts_with: String
  userName_ends_with: String
  userName_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  resetToken: String
  resetToken_not: String
  resetToken_in: [String!]
  resetToken_not_in: [String!]
  resetToken_lt: String
  resetToken_lte: String
  resetToken_gt: String
  resetToken_gte: String
  resetToken_contains: String
  resetToken_not_contains: String
  resetToken_starts_with: String
  resetToken_not_starts_with: String
  resetToken_ends_with: String
  resetToken_not_ends_with: String
  resetTokenExpiry: Float
  resetTokenExpiry_not: Float
  resetTokenExpiry_in: [Float!]
  resetTokenExpiry_not_in: [Float!]
  resetTokenExpiry_lt: Float
  resetTokenExpiry_lte: Float
  resetTokenExpiry_gt: Float
  resetTokenExpiry_gte: Float
  active: Boolean
  active_not: Boolean
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  urlAvatar: String
  isOnline: Boolean
  lastTimeOnl: DateTime
  freelancer: FreelancerUpdateOneWithoutUserInput
  employer: EmployerUpdateOneWithoutUserInput
  fullName: String
  email: String
  userName: String
  password: String
  resetToken: String
  resetTokenExpiry: Float
  permissions: UserUpdatepermissionsInput
  conversations: ConversationUpdateManyWithoutParticipantsInput
  active: Boolean
  tags: UserUpdatetagsInput
}

input UserUpdateInput {
  urlAvatar: String
  isOnline: Boolean
  lastTimeOnl: DateTime
  freelancer: FreelancerUpdateOneWithoutUserInput
  employer: EmployerUpdateOneWithoutUserInput
  fullName: String
  email: String
  userName: String
  password: String
  resetToken: String
  resetTokenExpiry: Float
  permissions: UserUpdatepermissionsInput
  conversations: ConversationUpdateManyWithoutParticipantsInput
  active: Boolean
  tags: UserUpdatetagsInput
}

input UserUpdateManyDataInput {
  urlAvatar: String
  isOnline: Boolean
  lastTimeOnl: DateTime
  fullName: String
  email: String
  userName: String
  password: String
  resetToken: String
  resetTokenExpiry: Float
  permissions: UserUpdatepermissionsInput
  active: Boolean
  tags: UserUpdatetagsInput
}

input UserUpdateManyMutationInput {
  urlAvatar: String
  isOnline: Boolean
  lastTimeOnl: DateTime
  fullName: String
  email: String
  userName: String
  password: String
  resetToken: String
  resetTokenExpiry: Float
  permissions: UserUpdatepermissionsInput
  active: Boolean
  tags: UserUpdatetagsInput
}

input UserUpdateManyWithoutConversationsInput {
  create: [UserCreateWithoutConversationsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutConversationsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutConversationsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutEmployerInput {
  create: UserCreateWithoutEmployerInput
  update: UserUpdateWithoutEmployerDataInput
  upsert: UserUpsertWithoutEmployerInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutFreelancerInput {
  create: UserCreateWithoutFreelancerInput
  update: UserUpdateWithoutFreelancerDataInput
  upsert: UserUpsertWithoutFreelancerInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdatepermissionsInput {
  set: [Permission!]
}

input UserUpdatetagsInput {
  set: [String!]
}

input UserUpdateWithoutConversationsDataInput {
  urlAvatar: String
  isOnline: Boolean
  lastTimeOnl: DateTime
  freelancer: FreelancerUpdateOneWithoutUserInput
  employer: EmployerUpdateOneWithoutUserInput
  fullName: String
  email: String
  userName: String
  password: String
  resetToken: String
  resetTokenExpiry: Float
  permissions: UserUpdatepermissionsInput
  active: Boolean
  tags: UserUpdatetagsInput
}

input UserUpdateWithoutEmployerDataInput {
  urlAvatar: String
  isOnline: Boolean
  lastTimeOnl: DateTime
  freelancer: FreelancerUpdateOneWithoutUserInput
  fullName: String
  email: String
  userName: String
  password: String
  resetToken: String
  resetTokenExpiry: Float
  permissions: UserUpdatepermissionsInput
  conversations: ConversationUpdateManyWithoutParticipantsInput
  active: Boolean
  tags: UserUpdatetagsInput
}

input UserUpdateWithoutFreelancerDataInput {
  urlAvatar: String
  isOnline: Boolean
  lastTimeOnl: DateTime
  employer: EmployerUpdateOneWithoutUserInput
  fullName: String
  email: String
  userName: String
  password: String
  resetToken: String
  resetTokenExpiry: Float
  permissions: UserUpdatepermissionsInput
  conversations: ConversationUpdateManyWithoutParticipantsInput
  active: Boolean
  tags: UserUpdatetagsInput
}

input UserUpdateWithWhereUniqueWithoutConversationsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutConversationsDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutEmployerInput {
  update: UserUpdateWithoutEmployerDataInput!
  create: UserCreateWithoutEmployerInput!
}

input UserUpsertWithoutFreelancerInput {
  update: UserUpdateWithoutFreelancerDataInput!
  create: UserCreateWithoutFreelancerInput!
}

input UserUpsertWithWhereUniqueWithoutConversationsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutConversationsDataInput!
  create: UserCreateWithoutConversationsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  urlAvatar: String
  urlAvatar_not: String
  urlAvatar_in: [String!]
  urlAvatar_not_in: [String!]
  urlAvatar_lt: String
  urlAvatar_lte: String
  urlAvatar_gt: String
  urlAvatar_gte: String
  urlAvatar_contains: String
  urlAvatar_not_contains: String
  urlAvatar_starts_with: String
  urlAvatar_not_starts_with: String
  urlAvatar_ends_with: String
  urlAvatar_not_ends_with: String
  isOnline: Boolean
  isOnline_not: Boolean
  lastTimeOnl: DateTime
  lastTimeOnl_not: DateTime
  lastTimeOnl_in: [DateTime!]
  lastTimeOnl_not_in: [DateTime!]
  lastTimeOnl_lt: DateTime
  lastTimeOnl_lte: DateTime
  lastTimeOnl_gt: DateTime
  lastTimeOnl_gte: DateTime
  freelancer: FreelancerWhereInput
  employer: EmployerWhereInput
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  userName: String
  userName_not: String
  userName_in: [String!]
  userName_not_in: [String!]
  userName_lt: String
  userName_lte: String
  userName_gt: String
  userName_gte: String
  userName_contains: String
  userName_not_contains: String
  userName_starts_with: String
  userName_not_starts_with: String
  userName_ends_with: String
  userName_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  resetToken: String
  resetToken_not: String
  resetToken_in: [String!]
  resetToken_not_in: [String!]
  resetToken_lt: String
  resetToken_lte: String
  resetToken_gt: String
  resetToken_gte: String
  resetToken_contains: String
  resetToken_not_contains: String
  resetToken_starts_with: String
  resetToken_not_starts_with: String
  resetToken_ends_with: String
  resetToken_not_ends_with: String
  resetTokenExpiry: Float
  resetTokenExpiry_not: Float
  resetTokenExpiry_in: [Float!]
  resetTokenExpiry_not_in: [Float!]
  resetTokenExpiry_lt: Float
  resetTokenExpiry_lte: Float
  resetTokenExpiry_gt: Float
  resetTokenExpiry_gte: Float
  conversations_every: ConversationWhereInput
  conversations_some: ConversationWhereInput
  conversations_none: ConversationWhereInput
  active: Boolean
  active_not: Boolean
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
  userName: String
}
`
      }
    